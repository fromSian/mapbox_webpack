/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import"../../../geometry.js";import t from"../../../request.js";import r from"../../../core/Error.js";import{JSONSupport as o}from"../../../core/JSONSupport.js";import i from"../../../core/Logger.js";import{isSome as n,isNone as s,unwrap as a}from"../../../core/maybe.js";import{EsriPromiseMixin as l}from"../../../core/Promise.js";import{onAbort as c}from"../../../core/promiseUtils.js";import{property as u}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/arrayUtils.js";import"../../../core/has.js";import"../../../core/accessorSupport/ensureType.js";import{subclass as f}from"../../../core/accessorSupport/decorators/subclass.js";import{sanitizeUrl as m}from"../arcgisLayerUrl.js";import{url as h}from"../commonProperties.js";import d from"../RasterStorageInfo.js";import p from"../TileInfo.js";import{getRasterId as x,getBlock as g,putBlock as y,deleteBlock as I,decreaseRefCount as w}from"./RawBlockCache.js";import{decode as R}from"../rasterFormats/RasterCodec.js";import{mosaic as v,approximateTransform as k}from"../rasterFunctions/pixelUtils.js";import{load as b,projectPoint as T,snapPyramid as C,snapExtent as M,getWorldWidth as P,getWorldWrapCount as S,projectExtent as B,getProjectionOffsetGrid as j,getRasterDatasetAlignmentInfo as F,projectResolution as W}from"../rasterFunctions/rasterProjectionHelper.js";import{uvComponentToVector as H}from"../rasterFunctions/vectorFieldUtils.js";import _ from"../../../geometry/Extent.js";import L from"../../../geometry/Point.js";const A=8;let D=class extends(l(o)){constructor(){super(...arguments),this.rasterJobHandler=null,this.datasetName=null,this.datasetFormat=null,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const e=b();this.addResolvingPromise(e),await this.when()}normalizeCtorArgs(e){return e&&e.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:p.create(),...e.ioConfig}}),e}set url(e){this._set("url",m(e,i.getLogger(this.declaredClass)))}async open(e){throw new r("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(e,t,r,o={}){const i=o.tileInfo||this.rasterInfo.storageInfo.tileInfo,n=this.getTileExtentFromTileInfo(e,t,r,i);return this.fetchPixels(n,i.size[0],i.size[1],o)}async identify(e,t={}){t=this._getRequestOptionsWithSliceId(t);const{spatialReference:r,extent:o}=this.rasterInfo,{datumTransformation:i}=t;let a=T(e,r,i);if(!o.intersects(a))return{location:a,value:null};if(n(this.rasterInfo.transform)){const e=this.rasterInfo.transform.inverseTransform(a);if(!this.rasterInfo.nativeExtent.intersects(e))return{location:e,value:null};a=e}let l=0;if(t.srcResolution){l=C(t.srcResolution,this.rasterInfo,this.ioConfig.sampling).pyramidLevel}else if(l=await this.computeBestPyramidLevelForLocation(e,t),null==l)return{location:a,value:null};const c=this.identifyPixelLocation(a,l,null);if(null===c)return{location:a,value:null};const{row:u,col:f,rowOffset:m,colOffset:h}=c,d=x(this.url,t.sliceId),p=`${l}/${u}/${f}`;let I=g(d,null,p);s(I)&&(I=this.fetchRawTile(l,u,f,t),y(d,null,p,I));const w=await I;if(s(w)||!w.pixels||0===w.pixels.length)return{location:a,value:null};const R=m*this.rasterInfo.storageInfo.blockHeight+h,v=!w.mask||w.mask[R]?w.pixels.map((e=>e[R])):null,k=this.rasterInfo.dataType;if(("vector-magdir"===k||"vector-uv"===k)&&(null==v?void 0:v.length)>1){return{location:a,value:v,magdirValue:"vector-magdir"===k?[v[0],v[1]]:H([v[0],v[1]]),pyramidLevel:l}}return{location:a,value:v,pyramidLevel:l}}async fetchPixels(e,t,r,o={}){e=M(e);const i=P(e.spatialReference),a=S(e),l=P(this.rasterInfo.spatialReference),c=n(l)&&this.rasterInfo.extent.width>=l/2;if(o=this._getRequestOptionsWithSliceId(o),s(i)||0===a||1===a&&c)return this._fetchPixels(e,t,r,o);if(a>=3)return{extent:e,pixelBlock:null};const u=[],{xmin:f,xmax:m}=e,h=Math.round(i/(m-f)*t),d=h-Math.round((i/2-f)/(m-f)*t);let p=0;const x=[];for(let n=0;n<=a;n++){const s=new _({xmin:0===n?f:-i/2,xmax:n===a?m-i*n:i/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),l=0===n?h-d:n===a?t-p:h;p+=l,x.push(l);const c=this._fetchPixels(s,l,r,o);u.push(c)}const g=(await Promise.all(u)).map((e=>null==e?void 0:e.pixelBlock));let y=null;const I={width:t,height:r};y=this.rasterJobHandler?await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:g,srcMosaicSize:I,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:x},o):v(g,I,{blockWidths:x});return{extent:e,srcExtent:B(e,this.rasterInfo.spatialReference,o.datumTransformation),pixelBlock:y}}async fetchRawPixels(e,t,r,o){const{origin:i,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:s,blockHeight:l}=this.getBlockWidthHeight(e);let{x:c,y:u}=t,{width:f,height:m,wrapCount:h}=r;const d=a(this._getRasterTileAlignmentInfo(e,0));o.buffer&&(c-=o.buffer.cols,u-=o.buffer.rows,f+=2*o.buffer.cols,m+=2*o.buffer.rows);const p=Math.floor(c/s),x=Math.floor(u/l),g=Math.floor((c+f-1)/s),y=Math.floor((u+m-1)/l),I=n[e];if(!I)return null;const{minRow:w,minCol:R,maxCol:v,maxRow:k}=I;if(0===h&&(y<w||g<R||x>k||p>v))return null;const b=new Array;let T=!1;const C=null==this.ioConfig.allowPartialFill?o.allowPartialFill:this.ioConfig.allowPartialFill;for(let a=x;a<=y;a++)for(let t=p;t<=g;t++){const r=0===h||null==d||t<d.worldColumnCountFromOrigin?t:t%d.worldColumnCountFromOrigin-d.originColumnOffset;if(a>=w&&r>=R&&k>=a&&v>=r){const t=this._fetchRawTile(e,a,r,o);C?b.push(new Promise((e=>{t.then((t=>e(t))).catch((()=>{T=!0,e(null)}))}))):b.push(t)}else b.push(null)}if(0===b.length)return null;const M=await Promise.all(b),P={height:(y-x+1)*l,width:(g-p+1)*s},{spatialReference:S}=this.rasterInfo,B=this.getPyramidPixelSize(e),{x:j,y:F}=B;return{extent:new _({xmin:i.x+p*s*j,xmax:i.x+(g+1)*s*j,ymin:i.y-(y+1)*l*F,ymax:i.y-x*l*F,spatialReference:S}),pixelBlocks:M,mosaicSize:P,isPartiallyFilled:T}}fetchRawTile(e,t,o,i){throw new r("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return B(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?R(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,r,o){var i,n;const{customFetchParameters:s}=this.ioConfig,{range:a,query:l,headers:c}=r;o=null!=(i=null!=(n=o)?n:r.retryCount)?i:this.ioConfig.retryCount;const u=a?{Range:`bytes=${a.from}-${a.to}`}:null;try{return await t(e,{...r,query:{...l,...s},headers:{...c,...u}})}catch(f){if(o>0)return o--,this.request(e,r,o);throw f}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;if(!n(t))return null;if(!n(e)||0===e.length)return null;let r=0;const o=e[0].variableName;for(let i=0;i<t.variables.length;i++){const n=t.variables[i],s=n.dimensions;if(n.name!==o){r+=s.map((e=>this._getDimensionValuesCount(e))).reduce(((e,t)=>e+t));break}const a=s.map((e=>this._getDimensionValuesCount(e))),l=s.length;for(let t=0;t<l;t++){const o=e.filter((e=>e.dimensionName===s[t].name))[0];if(null==o)return null;const i=Array.isArray(o.values[0])?o.values[0][0]:o.values[0],n=this._getIndexFromDimensions(i,s[t]);if(-1===n)return null;a.shift(),r+=t===l-1?n:n*a.reduce(((e,t)=>e+t))}}return r}getTileExtentFromTileInfo(e,t,r,o){const i=o.lodAt(e);return this.getTileExtent({x:i.resolution,y:i.resolution},t,r,o.origin,o.spatialReference,o.size)}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:r,pixelSize:o}=this.rasterInfo;if(!e.tileInfo){const i=[],n=e.maximumPyramidLevel||0;let s=Math.max(o.x,o.y),a=1/.0254*96*s;for(let e=0;e<=n;e++)i.push({level:n-e,resolution:s,scale:a}),s*=2,a*=2;const l=new L({x:r.xmin,y:r.ymax,spatialReference:t});e.tileInfo=new p({origin:l,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:i}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,r=512,o){const{width:i,height:n,nativeExtent:s,pixelSize:a,spatialReference:l}=e,c=new L({x:s.xmin,y:s.ymax,spatialReference:l});null==o&&(o=Math.max(0,Math.round(Math.log(Math.max(i,n))/Math.LN2-8)));const u=this.computeBlockBoundary(s,512,512,{x:s.xmin,y:s.ymax},[a],o);e.storageInfo=new d({blockWidth:t,blockHeight:r,pyramidBlockWidth:t,pyramidBlockHeight:r,origin:c,firstPyramidLevel:1,maximumPyramidLevel:o,blockBoundary:u})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,r,o,i,n=0,s=2){if(1===i.length&&n>0){i=[...i];let{x:e,y:t}=i[0];for(let r=0;r<n;r++)e*=s,t*=s,i.push({x:e,y:t})}const a=[],{x:l,y:c}=o;for(let u=0;u<i.length;u++){const{x:o,y:n}=i[u];a.push({minCol:Math.floor((e.xmin-l+.1*o)/t/o),maxCol:Math.floor((e.xmax-l-.1*o)/t/o),minRow:Math.floor((c-e.ymax+.1*n)/r/n),maxRow:Math.floor((c-e.ymin-.1*n)/r/n)})}return a}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:o}=this.rasterInfo.storageInfo;if(0===e)return t;if(n(r)&&r.length)return r[e-1];const i=o**e;return{x:t.x*i,y:t.y*i}}identifyPixelLocation(e,t,r){const{spatialReference:o,nativeExtent:i}=this.rasterInfo,{blockWidth:n,blockHeight:s,maximumPyramidLevel:a,origin:l}=this.rasterInfo.storageInfo,c=T(e,o,r);if(!i.intersects(c))return null;if(t<0||t>a)return null;const u=this.getPyramidPixelSize(t),{x:f,y:m}=u,h=(l.y-c.y)/m/s,d=(c.x-l.x)/f/n,p=Math.min(s-1,Math.floor((h-Math.floor(h))*s)),x=Math.min(n-1,Math.floor((d-Math.floor(d))*n));return{pyramidLevel:t,row:Math.floor(h),col:Math.floor(d),rowOffset:p,colOffset:x,srcLocation:c}}getTileExtent(e,t,r,o,i,n){const[s,a]=n,l=o.x+r*s*e.x,c=l+s*e.x,u=o.y-t*a*e.y,f=u-a*e.y;return new _({xmin:l,xmax:c,ymin:f,ymax:u,spatialReference:i})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,r){const o=this.rasterInfo.storageInfo.blockBoundary[e];return!o||o.maxRow<t||o.maxCol<r||o.minRow>t||o.minCol>r}async _fetchPixels(e,t,r,o={}){let i=S(e);if(i>=2)return{extent:e,pixelBlock:null};const n=this._getSourceDataInfo(e,t,r,o),{pyramidLevel:s,pyramidResolution:l,srcResolution:c,srcExtent:u,srcWidth:f,srcHeight:m}=n;if(0===f||0===m)return{extent:e,srcExtent:u,pixelBlock:null};const h=a(this.rasterInfo.transform);"gcs-shift"===(null==h?void 0:h.type)&&(i=S(n.srcExtent,!0));const d=this.rasterInfo.storageInfo,p={x:Math.floor((u.xmin-d.origin.x)/l.x+.1),y:Math.floor((d.origin.y-u.ymax)/l.y+.1)},x=await this.fetchRawPixels(s,p,{width:f,height:m,wrapCount:i},o);if(!x)return{extent:e,srcExtent:u,pixelBlock:null};const g=s>0?d.pyramidBlockWidth:d.blockWidth,y=s>0?d.pyramidBlockHeight:d.blockHeight,I=g===f&&y===m&&p.x%g==0&&p.y%y==0,w=new L({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/r,spatialReference:e.spatialReference}),R=!e.spatialReference.equals(this.rasterInfo.spatialReference),{datumTransformation:b}=o;if(!R&&I&&1===x.pixelBlocks.length&&g===t&&y===r&&c.x===w.x&&c.y===w.y)return{extent:e,srcExtent:u,pixelBlock:x.pixelBlocks[0]};const T=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:w.toJSON(),datumTransformation:b,rasterTransform:h,hasWrapAround:i>0,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy},o):j({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:w,datumTransformation:b,rasterTransform:h,hasWrapAround:i>0,isAdaptive:!1});let C;const M=!o.requestRawData,P={rows:T.spacing[0],cols:T.spacing[1]},B=a(this._getRasterTileAlignmentInfo(s,x.extent.xmin)),{pixelBlocks:F,mosaicSize:W,isPartiallyFilled:H}=x;if(this.rasterJobHandler)C=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:F,srcMosaicSize:W,destDimension:M?{width:t,height:r}:null,coefs:M?T.coefficients:null,sampleSpacing:M?P:null,interpolation:o.interpolation,alignmentInfo:B,blockWidths:null},o);else{const e=v(F,W,{alignmentInfo:B});C=M?k(e,{width:t,height:r},T.coefficients,P,o.interpolation):e}return o.requestRawData?{srcExtent:u,pixelBlock:C,transformGrid:T,extent:e,isPartiallyFilled:H}:{srcExtent:u,extent:e,pixelBlock:C}}_fetchRawTile(e,t,r,o){const i=this.rasterInfo.storageInfo.blockBoundary[e];if(!i)return Promise.resolve(null);const{minRow:n,minCol:a,maxCol:l,maxRow:u}=i;if(t<n||r<a||t>u||r>l)return Promise.resolve(null);const f=x(this.url,o.sliceId),m=`${e}/${t}/${r}`;let h=g(f,o.registryId,m);if(s(h)){const i=new AbortController;h=this.fetchRawTile(e,t,r,{...o,signal:i.signal}),y(f,o.registryId,m,h,i),h.catch((()=>I(f,o.registryId,m)))}return o.signal&&c(o,(()=>{w(f,o.registryId,m)})),h}_getIndexFromDimensions(e,t){const{extent:r,interval:o,unit:i,values:n}=t;if(null!=n&&n.length)return Array.isArray(n[0])?n.findIndex((t=>t[0]<=e&&t[1]>=e)):n.indexOf(e);if(e>r[1])return-1;const s=r[0];let a=-1;if("ISO8601"===i){var l;switch((null==(l=t.intervalUnit)?void 0:l.toLowerCase())||"seconds"){case"seconds":a=Math.round((e-s)/1e3/o);break;case"minutes":a=Math.round((e-s)/6e4/o);break;case"hours":a=Math.round((e-s)/36e5/o);break;case"days":a=Math.round((e-s)/864e5/o);break;case"years":a=Math.round((new Date(e).getUTCFullYear()-new Date(s).getUTCFullYear())/o);break;case"decades":a=Math.round((new Date(e).getUTCFullYear()-new Date(s).getUTCFullYear())/10/o)}return a}return Math.round((e-s)/o)}_getDimensionValuesCount(e){const{extent:t,interval:r,unit:o,values:i}=e;let n=(null==i?void 0:i.length)||0;if(n)return n;const s=t[0];if(0===n&&"ISO8601"===o){var a;switch((null==(a=e.intervalUnit)?void 0:a.toLowerCase())||"seconds"){case"seconds":n=Math.round((t[1]-t[0])/1e3/r);break;case"minutes":n=Math.round((t[1]-t[0])/6e4/r);break;case"hours":n=Math.round((t[1]-t[0])/36e5/r);break;case"days":n=Math.round((t[1]-t[0])/864e5/r);break;case"years":n=Math.round((new Date(t[1]).getUTCFullYear()-new Date(s).getUTCFullYear())/r);break;case"decades":n=Math.round((new Date(t[1]).getUTCFullYear()-new Date(s).getUTCFullYear())/10/r)}return n}return Math.round((t[1]-t[0])/r)}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=F(this.rasterInfo)),n(this._rasterTileAlighmentInfo.pyramidsInfo)?{startX:t,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[e]}:null}_getSourceDataInfo(e,t,r,o={}){const i={datumTransformation:o.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0};o.srcResolution&&(i.srcResolution=o.srcResolution,this._updateSourceDataInfo(e,i));const n=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:s,srcHeight:a,pyramidLevel:l}=i,c=s/t,u=a/r,f=l<n&&c*u>=16;if(f||l===n&&(c>A||u>A)||(0===s||0===a)){const s=new L({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/r,spatialReference:e.spatialReference});let a=W(s,this.rasterInfo.spatialReference,e,i.datumTransformation);const m=!a||o.srcResolution&&a.x+a.y<o.srcResolution.x+o.srcResolution.y;if(f&&o.srcResolution&&m){const e=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(n-l+3>=e){const t=2**e;a={x:o.srcResolution.x*t,y:o.srcResolution.y*t}}}a&&(i.srcResolution=a,this._updateSourceDataInfo(e,i))}return(i.srcWidth/t>A||i.srcHeight/r>A)&&(i.srcWidth=0,i.srcHeight=0),i}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;const r=this.rasterInfo.spatialReference,{srcResolution:o,datumTransformation:i}=t,{pyramidLevel:n,pyramidResolution:s,excessiveReading:l}=C(o,this.rasterInfo,this.ioConfig.sampling);if(l)return;let c=t.srcExtent||B(e,r,i);if(null==c)return;const u=a(this.rasterInfo.transform);u&&(c=u.inverseTransform(c)),t.srcExtent=c;const f=Math.ceil((c.xmax-c.xmin)/s.x-.1),m=Math.ceil((c.ymax-c.ymin)/s.y-.1);t.pyramidLevel=n,t.pyramidResolution=s,t.srcWidth=f,t.srcHeight=m}_getRequestOptionsWithSliceId(e){return n(this.rasterInfo.multidimensionalInfo)&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}};e([u()],D.prototype,"_rasterTileAlighmentInfo",void 0),e([u(h)],D.prototype,"url",null),e([u({type:String,json:{write:!0}})],D.prototype,"datasetName",void 0),e([u({type:String,json:{write:!0}})],D.prototype,"datasetFormat",void 0),e([u()],D.prototype,"rasterInfo",void 0),e([u()],D.prototype,"ioConfig",void 0),e([u()],D.prototype,"sourceJSON",void 0),D=e([f("esri.layers.support.rasterDatasets.BaseRaster")],D);const E=D;export{E as default};
