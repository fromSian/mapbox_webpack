/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{_ as r}from"../../../../chunks/tslib.es6.js";import{ReloadableShaderModule as i}from"../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as e}from"../core/shaderTechnique/ShaderTechnique.js";import{parameter as t,ShaderTechniqueConfiguration as o}from"../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{Default3D as s}from"../lib/DefaultVertexAttributeLocations.js";import{blendingDefault as a}from"../lib/OrderIndependentTransparency.js";import{Program as n}from"../lib/Program.js";import{S as p}from"../../../../chunks/ShadowCast.glsl.js";import{makePipelineState as h,defaultColorWriteParams as l,separateBlendingParams as m}from"../../../webgl/renderState.js";class c extends e{initializeProgram(r){const i=c.shader.get().build(this.configuration);return new n(r.rctx,i,s)}initializePipeline(r){switch(this.configuration.pass){case 0:return h({blending:m(1,1,1,1),colorWrite:l,depthTest:null,depthWrite:null});case 1:case 2:return h({blending:a,colorWrite:l,depthTest:null,depthWrite:null})}return h({})}bindPass(r){if(0===this.configuration.pass||2===this.configuration.pass){const i=r;this.program.bindTexture(i.linearDepthTexture,"depthMap"),i.shadowMap.bind(this.program),i.shadowMap.bindView(this.program,i.camera.center),this.program.setUniform2fv("nearFar",i.camera.nearFar),this.program.setUniformMatrix4fv("inverseView",i.inverseView),this.program.setUniform4fv("projInfo",i.projInfo),this.program.setUniform2fv("zScale",i.zScale)}else if(1===this.configuration.pass){const i=r;if(this.program.bindTexture(i.shadowCastMap,"shadowCastMap"),this.program.setUniform1f("sampleScale",i.sampleScale),this.program.setUniform1f("opacityFromElevation",i.opacityFromElevation),this.program.setUniform4fv("color",i.color),0===this.configuration.visualization&&this.configuration.bandsEnabled){const i=r;this.program.setUniform1f("bandSize",i.bandSize)}else if(1===this.configuration.visualization){const i=r;this.program.setUniform1f("threshold",i.threshold)}}}get primitiveType(){return 5}}c.shader=new i(p,(()=>import("./ShadowCast.glsl.js")));class d extends o{constructor(){super(...arguments),this.pass=0,this.visualization=0,this.bandsEnabled=!1}}r([t({count:3})],d.prototype,"pass",void 0),r([t()],d.prototype,"visualization",void 0),r([t()],d.prototype,"bandsEnabled",void 0);export{c as ShadowCastTechnique,d as ShadowCastTechniqueConfiguration};
