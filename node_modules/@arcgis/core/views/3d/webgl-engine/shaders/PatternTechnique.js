/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import{bindSliceUniformsWithOrigin as t}from"../core/shaderLibrary/Slice.glsl.js";import{bindOutputHighlight as r}from"../core/shaderLibrary/output/OutputHighlight.glsl.js";import{bindMultipassTerrainTexture as i}from"../core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{bindProjectionMatrix as o,bindView as s,bindCameraPosition as a}from"../core/shaderLibrary/util/View.glsl.js";import{ReloadableShaderModule as n}from"../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as l}from"../core/shaderTechnique/ShaderTechnique.js";import{parameter as p,ShaderTechniqueConfiguration as c}from"../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{blendingDefault as u,OITBlending as d,OITDepthTest as h,OITDepthWrite as m,getOITPolygonOffset as g}from"../lib/OrderIndependentTransparency.js";import{Program as f}from"../lib/Program.js";import{stencilWriteMaskOn as b,stencilToolMaskBaseParams as y,stencilBaseAllZerosParams as v}from"../lib/StencilUtils.js";import{P}from"../../../../chunks/Pattern.glsl.js";import{makePipelineState as T,cullingParams as S,defaultDepthWriteParams as j,defaultColorWriteParams as w}from"../../../webgl/renderState.js";class x extends l{initializeProgram(e){const t=x.shader.get(),r=this.configuration,i=t.build({output:r.output,attributeColor:r.vertexColors,slicePlaneEnabled:r.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,style:r.style,patternSpacing:r.patternSpacing,lineWidth:r.lineWidth,draped:r.draped,OITEnabled:0===r.transparencyPassType,multipassTerrainEnabled:r.multipassTerrainEnabled,cullAboveGround:r.cullAboveGround});return new f(e.rctx,i,C)}bindPass(e,t){o(this.program,t.camera.projectionMatrix),this.program.setUniform4fv("matColor",e.color),this.configuration.draped?(this.program.setUniform1f("worldToScreenRatio",1/t.screenToPCSRatio),this.program.setUniform1f("texelSize",1/t.camera.pixelRatio)):this.program.setUniform1f("worldToScreenPerDistanceRatio",1/t.camera.perScreenPixelRatio),4===this.configuration.output&&r(this.program,t),(1===this.configuration.output||t.multipassTerrainEnabled)&&this.program.setUniform2fv("cameraNearFar",t.camera.nearFar),t.multipassTerrainEnabled&&(this.program.setUniform2fv("inverseViewport",t.inverseViewport),i(this.program,t))}bindDraw(e){s(this.program,e),a(this.program,e.origin,e.camera.viewInverseTransposeMatrix),t(this.program,this.configuration,e),this.program.rebindTextures()}setPipelineState(e,t){const r=this.configuration,i=3===e,o=2===e;return T({blending:0===r.output||7===r.output?i?u:d(e):null,culling:S(r.cullFace),depthTest:{func:h(e)},depthWrite:i?r.writeDepth&&j:m(e),colorWrite:w,stencilWrite:r.sceneHasOcludees?b:null,stencilTest:r.sceneHasOcludees?t?y:v:null,polygonOffset:i||o?r.polygonOffset&&O:g(r.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this.setPipelineState(this.configuration.transparencyPassType,!0),this.setPipelineState(this.configuration.transparencyPassType,!1)}getPipelineState(e,t){return t?this._occludeePipelineState:super.getPipelineState(e,t)}}x.shader=new n(P,(()=>import("./Pattern.glsl.js")));const O={factor:1,units:1};class E extends c{constructor(){super(...arguments),this.output=0,this.cullFace=0,this.slicePlaneEnabled=!1,this.vertexColors=!1,this.polygonOffset=!1,this.writeDepth=!0,this.sceneHasOcludees=!1,this.enableOffset=!0,this.transparencyPassType=3,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}e([p({count:8})],E.prototype,"output",void 0),e([p({count:3})],E.prototype,"cullFace",void 0),e([p()],E.prototype,"slicePlaneEnabled",void 0),e([p()],E.prototype,"vertexColors",void 0),e([p()],E.prototype,"polygonOffset",void 0),e([p()],E.prototype,"writeDepth",void 0),e([p()],E.prototype,"sceneHasOcludees",void 0),e([p({count:6})],E.prototype,"style",void 0),e([p()],E.prototype,"patternSpacing",void 0),e([p()],E.prototype,"lineWidth",void 0),e([p()],E.prototype,"enableOffset",void 0),e([p()],E.prototype,"draped",void 0),e([p({count:4})],E.prototype,"transparencyPassType",void 0),e([p()],E.prototype,"multipassTerrainEnabled",void 0),e([p()],E.prototype,"cullAboveGround",void 0);const C=new Map([["position",0],["color",3],["uvMapSpace",4],["boundingRect",5]]);export{x as PatternTechnique,E as PatternTechniqueConfiguration,C as patternVertexAttributeLocations};
