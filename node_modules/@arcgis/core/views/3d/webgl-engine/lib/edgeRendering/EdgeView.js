/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import t from"../../../../../core/Accessor.js";import{equals as r}from"../../../../../core/arrayUtils.js";import s from"../../../../../core/Logger.js";import{clamp as o}from"../../../../../core/mathUtils.js";import{disposeMaybe as i,destroyMaybe as n,isNone as a,isSome as c}from"../../../../../core/maybe.js";import{property as d}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/ensureType.js";import{subclass as l}from"../../../../../core/accessorSupport/decorators/subclass.js";import{f as g,t as u,e as h}from"../../../../../chunks/mat3.js";import{c as m}from"../../../../../chunks/mat3f64.js";import{c as p}from"../../../../../chunks/mat4.js";import{c as f}from"../../../../../chunks/mat4f64.js";import{s as b,g as y,v as j,d as v}from"../../../../../chunks/vec3.js";import{c as w}from"../../../../../chunks/vec3f64.js";import{g as O,l as E}from"../../../../../chunks/sphere.js";import{c as x}from"../../../../../chunks/vec33.js";import{VertexPosition as R}from"../../core/shaderLibrary/attributes/VertexPosition.glsl.js";import{TwoVectorPosition as M}from"../../core/util/TwoVectorPosition.js";import{GridLocalOriginFactory as C}from"../GridLocalOriginFactory.js";import{applyToModelMatrix as T}from"../localOriginHelper.js";import{LocalOriginManager as D}from"../LocalOriginManager.js";import{Object3D as k}from"../Object3D.js";import{VertexLayout as B,EdgeShaderAttributeLocations as P,glVertexLayout as L,EdgeInputBufferLayout as V}from"./bufferLayouts.js";import{RegularEdgeBufferWriter as A,SilhouetteEdgeBufferWriter as S}from"./edgeBufferWriters.js";import{EdgeRenderer as H,LINE_WIDTH_FRACTION_FACTOR as z,EXTENSION_LENGTH_OFFSET as U}from"./EdgeRenderer.js";import I from"./EdgeWorkerHandle.js";import{generateStrokesTexture as F}from"./strokes.js";import{determineRendererType as _,determineEdgeTransparency as G,determineObjectTransparency as K,fillComponenBufferIndices as q,computeEdgeCount as N}from"./util.js";import{BufferManager as W}from"../TextureBackedBuffer/BufferManager.js";import{WatchUpdatingTracking as J}from"../../../../support/WatchUpdatingTracking.js";import Q from"../../../../webgl/BufferObject.js";import X from"../../../../webgl/VertexArrayObject.js";const Y=s.getLogger("esri.views.3d.webgl-engine.lib.edgeRendering.EdgeView");let Z=class extends t{constructor(e){super(e),this.updatingHandles=new J,this.perObjectData=new Map,this.perObjectDataEvictionCache=new Set,this.renderers=new Map,this.numberOfRenderedEdges=0,this.gpuMemoryUsage=0,this.workerAbort=new AbortController,this.tmpModelPosition=w(),this.localOrigins=new D(new C(e.renderSR))}initialize(){this.worker=new I(this.schedule),this.componentColorManager=new W(this.rctx,2);const e=B.createBuffer(4);for(let t=0;t<4;t++)e.sideness.set(t,0,0===t||3===t?0:1),e.sideness.set(t,1,0===t||1===t?0:1);this.verticesBufferObject=Q.createVertex(this.rctx,35044,e.buffer)}destroy(){this.destroyed||(this.perObjectData.forEach((e=>this._discardObjectEntry(e))),this.perObjectData.clear(),this.strokesTexture=i(this.strokesTexture),this.componentColorManager=n(this.componentColorManager),this.workerAbort.abort(),this.worker.destroy(),this.verticesBufferObject=i(this.verticesBufferObject),this.renderers.clear(),this.updatingHandles.destroy())}get updating(){return this.updatingHandles.updating}get usedMemory(){return this.gpuMemoryUsage}get numberOfRenderedPrimitives(){return this.numberOfRenderedEdges}shouldRender(){return this.renderers.size>0}async addComponentObject(e,t,r,s,o,i,n,a){if(this.hasObject(e))return;let c;const d=new te(new Promise((e=>c=e)),r.center,r.radius);this.perObjectData.set(e,d),await this.updatingHandles.addPromise(this.addComponentGeometry(t,d,s,o,i,n,a)),this.setNeedsRender(),c()}async addOrUpdateObject3D(e,t,r,s){if(this.destroyed)return void Y.warn("Attempt to add an object to a destroyed instance");const o=this.perObjectData.get(e);let i;(null==o?void 0:o.renderables.length)>0&&this.perObjectDataEvictionCache.add(o);const n=e.boundingVolumeWorldSpace.bounds,a=new te(new Promise((e=>i=e)),O(n),E(n));this.perObjectData.set(e,a);const c=new Array;if(r.mergeGeometries&&e.geometries.length>1&&ee(e))c.push(this.addObjectMergedGeometries(e,a,t,r,s));else for(let d=0;d<e.geometries.length;d++){const o=e.geometryRecords[d];if(!o.material.supportsEdges)continue;const i=e.geometries[d];c.push(this.addGeometry(e,a,i,o,t[0],r,s))}await this.updatingHandles.addPromise(Promise.all(c)),this.perObjectDataEvictionCache.delete(a),this._discardObjectEntry(o),this.setNeedsRender(),i()}_discardObjectEntry(e){e&&(e.renderables.length&&(e.renderables.forEach((e=>this.removeRenderable(e))),this.setNeedsRender()),e.loaded=null)}hasObject(e){return this.perObjectData.has(e)}async updateAllComponentOpacities(e,t){const r=t instanceof Array?e=>t[e]:()=>t;(await this.updatingHandles.addPromise(this.getObjectEntry(e))).renderables.forEach((e=>{const t=e.components.meta.length;for(let s=0;s<t;s++){const t=r(s),o=e.components.meta[s],i=o.index;o.material.opacity=t,e.components.buffer.textureBuffer.setDataElement(i,1,3,255*t)}this.updateTransparency(e)})),this.setNeedsRender()}async updateAllComponentMaterials(e,t,r,s){const o=e instanceof k,i=!!r.slicePlaneEnabled,n=_(t),a=H.getKey(n,i,o);(await this.updatingHandles.addPromise(this.getObjectEntry(e))).renderables.forEach((e=>{if(a!==e.rendererKey){const t=this.renderers.get(e.rendererKey),r=this.acquireRenderer(n,i,o);t.removeRenderable(e),t.refCount.decrement(),e.rendererKey=a,r.addRenderable(e)}for(let r=0;r<t.length;r++)e.components.meta[r].material=t[r];s&&this.updateComponentBuffer(e.components),this.updateTransparency(e)})),this.setNeedsRender()}async updateObjectVisibility(e,t){(await this.updatingHandles.addPromise(this.getObjectEntry(e))).renderables.forEach((e=>e.visible=t)),this.setNeedsRender()}removeObject(e){const t=this.perObjectData.get(e);t&&(this.perObjectData.delete(e),this._discardObjectEntry(t))}async getObjectEntry(e){const t=this.perObjectData.get(e);if(!t)throw"no object";return await t.loaded,t}removeAll(){this.perObjectData.forEach(((e,t)=>this.removeObject(t)))}render(e,t){if(a(this.componentColorManager))return;this.localOrigins.updateViewMatrices(e.camera.viewMatrix);const r=e.camera.viewInverseTransposeMatrix,s=w(),o=new M,i=new R.ViewProjectionTransform,n=m();b(s,r[3],r[7],r[11]),o.set(s),y(i.worldFromView_TH,o.high),y(i.worldFromView_TL,o.low),g(i.viewFromCameraRelative_RS,e.camera.viewMatrix),p(i.projFromView,e.camera.projectionMatrix);const c=m();u(c,i.viewFromCameraRelative_RS),h(n,c);let d=0,l=0;if(this.renderers.forEach((e=>{0===e.refCount.value?(this.renderers.delete(e.key),e.dispose()):e.forEachRenderable((e=>{d+=e.statistics.averageEdgeLength,l++}),t)})),this.componentColorManager.garbageCollect(),this.componentColorManager.updateTextures(),0===l)return;const f={distanceFalloffFactor:40*d/l,minimumEdgeLength:e.camera.perScreenPixelRatio,transparency:t,viewProjectionTransform:i,transformNormal_ViewFromGlobal:n};this.updateObjectCameraDistances(e),this.numberOfRenderedEdges=0,this.renderers.forEach((t=>{this.renderRegularEdges(t,e,f),this.renderSilhouetteEdges(t,e,f)}))}updateTransparency(e){const t=G(e.components.meta),r=K(e.components.meta);t===e.edgeTransparency&&r===e.objectTransparency||(e.edgeTransparency=t,e.objectTransparency=r,this.renderers.get(e.rendererKey).setRenderablesDirty())}computeModelTransformWithLocalOrigin(e,t,r){if(e.getCombinedStaticTransformation(t,r),c(t.origin))this.localOrigins.register(t.origin);else{const e=b(this.tmpModelPosition,r[12],r[13],r[14]);t.origin=this.localOrigins.acquire(e)}return T(t.origin.vec3,r),t.origin}updateComponentBuffer(e){const{meta:t,buffer:r}=e;for(let s=0;s<t.length;s++){const e=t[s].material,i=t[s].index,n=o(Math.round(e.size*z),0,255),a=o(e.extensionLength,-U,255-U)+U,c="solid"===e.type?0:1,d=255*e.opacity,l=e.color,g=255*l[0],u=255*l[1],h=255*l[2],m=255*l[3];r.textureBuffer.setData(i,0,g,u,h,m),r.textureBuffer.setData(i,1,n,a,c,d)}}createComponentBuffers(e){if(a(this.componentColorManager))return null;const t=new Array,r=this.componentColorManager.getBuffer(e.length);for(let o=0;o<e.length;o++){const s=e[o],i=r.acquireIndex();t.push({index:i,material:s})}const s={meta:t,buffer:r};return this.updateComponentBuffer(s),s}extractEdges(e,t,r,s,o,i=o.length){return this.worker.process({data:t,indices:o,indicesLength:i,writerSettings:e,skipDeduplicate:r},this.workerAbort.signal,s)}createEdgeResources(e){const t={};if(a(this.verticesBufferObject))return t;if(e.regular.lodInfo.lengths.length>0){const r=new X(this.rctx,P,{vertices:L,instances:A.glLayout},{vertices:this.verticesBufferObject,instances:Q.createVertex(this.rctx,35044,e.regular.instancesData.buffer)});t.regular={vao:r,lod:e.regular.lodInfo}}if(e.silhouette.lodInfo.lengths.length>0){const r=new X(this.rctx,P,{vertices:L,instances:S.glLayout},{vertices:this.verticesBufferObject,instances:Q.createVertex(this.rctx,35044,e.silhouette.instancesData.buffer)});t.silhouette={vao:r,lod:e.silhouette.lodInfo}}return t}async addGeometry(e,t,r,s,o,i,n){const a=r.vertexAttributes.get("position"),c=r.indices.get("position"),d=f(),l={position:a,indices:c,modelTransform:d,origin:this.computeModelTransformWithLocalOrigin(e,s,d)};return this.addPositionData(t,l,r.edgeIndicesLength,o,i,n)}async addPositionData(e,t,r,s,o,i=!1){if(null==e.loaded)return;const n=this.createComponentBuffers([s]);if(a(n)||r<=0)return;const c=this.acquireRenderer(s.type,!!o.slicePlaneEnabled),{modelTransform:d,origin:l}=t,g=t.indices,u=t.position,h=u.data.length/u.size,m=V.createBuffer(h);for(let a=0;a<h;a++)m.position.set(a,0,u.data[a*u.size+0]),m.position.set(a,1,u.data[a*u.size+1]),m.position.set(a,2,u.data[a*u.size+2]);q(n.meta,[0,m.componentIndex.count],m.componentIndex);const p=await this.updatingHandles.addPromise(this.extractEdges(c.writerSettings,m,!1,i,g,r));if(null==e.loaded)return;const{regular:f,silhouette:b}=this.createEdgeResources(p),y=(f?f.vao.size:0)+(b?b.vao.size:0),j={regular:f,silhouette:b,transform:{modelMatrix:d,origin:l},statistics:{gpuMemoryUsage:y,averageEdgeLength:p.averageEdgeLength},components:n,visible:!0,edgeTransparency:G(n.meta),objectTransparency:K(n.meta),distanceToCamera:0,rendererKey:c.key};e.renderables.push(j),c.addRenderable(j),this.gpuMemoryUsage+=y}async addComponentGeometry(e,t,r,s,o,i,n){if(null==t.loaded)return;const c=this.createComponentBuffers(i);if(a(c))return;const d=_(i),l=this.acquireRenderer(d,n.slicePlaneEnabled||!1,!1),g=V.createBuffer(r.count);x(g.position,r),q(c.meta,o,g.componentIndex,s);const u=!0,h=l.writerSettings,m=await this.updatingHandles.addPromise(this.extractEdges(h,g,u,!1,s));if(null==t.loaded)return;const{regular:p,silhouette:f}=this.createEdgeResources(m),b=(p?p.vao.size:0)+(f?f.vao.size:0),y={regular:p,silhouette:f,transform:e,statistics:{gpuMemoryUsage:b,averageEdgeLength:m.averageEdgeLength},components:c,visible:!0,edgeTransparency:G(c.meta),objectTransparency:K(c.meta),distanceToCamera:0,rendererKey:l.key};t.renderables.push(y),l.addRenderable(y),this.gpuMemoryUsage+=b}async addObjectMergedGeometries(e,t,r,s,o){const i=new Map;let n=0,a=null,c=0;for(let f=0;f<e.geometries.length;f++){const t=e.geometries[f],r=e.geometryRecords[f];if(!r.material.supportsEdges)continue;!a&&r.origin&&(a=r);const s=t.vertexAttributes.get("position");c+=s.data.length/s.size,n+=t.edgeIndicesLength}const d=c>=65536?Uint32Array:Uint16Array,l=n?new d(n):null,g=[];let u=0;for(let f=0;f<e.geometries.length;f++){const t=e.geometries[f];if(!e.geometryRecords[f].material.supportsEdges)continue;const r=t.vertexAttributes.get("position"),s=t.indices.get("position");let o=i.get(r.data);if(null==o){o=g.length/3;for(let e=0;e<r.data.length;e+=r.size)g.push(r.data[e+0]),g.push(r.data[e+1]),g.push(r.data[e+2]);i.set(r.data,o)}if(s)for(let e=0;e<t.edgeIndicesLength;e++)l[u++]=o+s[e]}const h=a||e.geometryRecords[0],m=f(),p=this.computeModelTransformWithLocalOrigin(e,h,m);for(let f=0;f<e.geometryRecords.length;f++)e.geometryRecords[f].origin=p;const b={position:{data:g,size:3},indices:l,modelTransform:m,origin:p};await this.updatingHandles.addPromise(this.addPositionData(t,b,l.length,r[0],s,o))}acquireRenderer(e,t,r=!0){const s=H.getKey(e,t,r);let o=this.renderers.get(s);return a(this.strokesTexture)&&(this.strokesTexture=F(this.rctx)),o||(o=new H(this.rctx,this.techniqueRepository,{type:e,slicePlaneEnabled:t,strokesTexture:this.strokesTexture,legacy:r}),this.renderers.set(s,o)),o.refCount.increment(),o}removeRenderable(e){$(e);const t=this.renderers.get(e.rendererKey);if(t){t.removeRenderable(e),t.refCount.decrement(),"origin"in e.transform&&this.localOrigins.release(e.transform.origin),this.gpuMemoryUsage-=e.statistics.gpuMemoryUsage;for(const t of e.components.meta)e.components.buffer.releaseIndex(t.index)}}updateObjectCameraDistances(e){const t=e.camera.eye,r=e.camera.viewForward,s=w(),o=e=>{const{center:o,radius:i}=e;j(s,o,t);const n=v(s,r),a=n<-i?1/0:n<i?0:n-i;e.renderables.forEach((e=>e.distanceToCamera=a))};this.perObjectData.forEach(o),this.perObjectDataEvictionCache.forEach(o)}renderRegularEdges(e,t,r){e.bindRegularEdges(t,r);const s=r.transparency;e.forEachRenderable((s=>{if(!s.visible||!s.regular)return;const o=N(s.regular.lod.lengths,s.distanceToCamera,r);"origin"in s.transform&&(t.localViewMatrixForEdges=this.localOrigins.getViewMatrix(s.transform.origin)),e.renderRegularEdges(s,t,o),this.numberOfRenderedEdges+=o}),s)}renderSilhouetteEdges(e,t,r){e.bindSilhouetteEdges(t,r);const s=r.transparency;e.forEachRenderable((s=>{if(!s.visible||!s.silhouette)return;const o=N(s.silhouette.lod.lengths,s.distanceToCamera,r);"origin"in s.transform&&(t.localViewMatrixForEdges=this.localOrigins.getViewMatrix(s.transform.origin)),e.renderSilhouetteEdges(s,t,o),this.numberOfRenderedEdges+=o}),s)}};function $(e){e.regular&&(e.regular.vao.vertexBuffers.instances.dispose(),e.regular.vao.dispose(!1),e.regular.vao=null),e.silhouette&&(e.silhouette.vao.vertexBuffers.instances.dispose(),e.silhouette.vao.dispose(!1),e.silhouette.vao=null)}function ee(e){let t=null,s=null;for(let i=0;i<e.geometries.length;i++){var o;const n=e.geometryRecords[i];if(n.material.supportsEdges){if(t){if(!r(t,n.transformation))return!1}else t=n.transformation;if(!s&&c(n.origin))s=n;else if(c(null==(o=s)?void 0:o.origin)&&c(n.origin)&&s.origin.id!==n.origin.id)return!1}}return!0}e([d({constructOnly:!0})],Z.prototype,"rctx",void 0),e([d({constructOnly:!0})],Z.prototype,"renderSR",void 0),e([d({constructOnly:!0})],Z.prototype,"techniqueRepository",void 0),e([d({constructOnly:!0})],Z.prototype,"setNeedsRender",void 0),e([d({constructOnly:!0})],Z.prototype,"schedule",void 0),e([d({readOnly:!0})],Z.prototype,"updatingHandles",void 0),e([d({readOnly:!0})],Z.prototype,"updating",null),Z=e([l("esri.views.3d.webgl-engine.lib.edgeRendering.EdgeView")],Z);class te{constructor(e,t,r){this.center=t,this.radius=r,this.renderables=new Array,this.loaded=e,this.loaded.then((()=>{null!=this.loaded&&(this.loaded=!0)}))}}export{Z as EdgeView};
