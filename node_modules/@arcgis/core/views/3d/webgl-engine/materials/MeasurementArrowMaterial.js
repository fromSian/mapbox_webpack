/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{s as e,n as t,f as r,c as s,i as n,m as o}from"../../../../chunks/vec3.js";import{c as i}from"../../../../chunks/vec3f64.js";import{newLayout as a}from"../../support/buffer/InterleavedLayout.js";import u from"../lib/GLMaterial.js";import{Material as c,materialParametersDefaults as l}from"../lib/Material.js";import{MeasurementArrowTechniqueConfiguration as p,MeasurementArrowTechnique as f}from"../shaders/MeasurementArrowTechnique.js";class h extends c{constructor(e){super(e,d),this.techniqueConfig=new p}getTechniqueConfig(e,t){var r;return this.techniqueConfig.polygonOffsetEnabled=this.parameters.polygonOffset,this.techniqueConfig.transparent=this.parameters.stripeEvenColor[3]<1||this.parameters.stripeOddColor[3]<1||this.parameters.outlineColor[3]<1,this.techniqueConfig.transparencyPassType=null!=(r=null==t?void 0:t.transparencyPassType)?r:3,this.techniqueConfig}dispose(){}getPassParameters(){return this.parameters}intersect(){}requiresSlot(e){return 2===e}createGLMaterial(e){return 0===e.output?new m(e):null}createBufferWriter(){return new x}}class m extends u{updateParameters(e){return this.ensureTechnique(f,e)}beginSlot(e){return this.updateParameters(e)}bind(e,t){t.bindPass(this._material.getPassParameters(),e)}}const d={width:32,outlineSize:.2,outlineColor:[1,.5,0,1],stripeLength:1,stripeEvenColor:[1,1,1,1],stripeOddColor:[1,.5,0,1],polygonOffset:!1,...l},g=a().vec3f("position").vec3f("normal").vec2f("uv0").f32("auxpos1"),v=i(),C=i(),y=i(),b=i(),q=i();class x{constructor(){this.vertexBufferLayout=g}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 2*(e.indices.get("position").length/2+1)}write(i,a,u,c){const l=a.vertexAttributes.get("position").data,p=a.vertexAttributes.get("normal").data,f=l.length/3,h=a&&a.indices&&a.indices.get("position");h&&h.length!==2*(f-1)&&console.warn("MeasurementArrowMaterial does not support indices");const m=v,d=C,g=y,x=b,P=q,w=i.transformation,T=i.invTranspTransformation,j=u.position,L=u.normal,M=u.uv0;let O=0;for(let v=0;v<f;++v){const i=3*v;if(e(m,l[i],l[i+1],l[i+2]),v<f-1){const n=3*(v+1);e(d,l[n],l[n+1],l[n+2]),e(P,p[n],p[n+1],p[n+2]),t(P,P),r(g,d,m),t(g,g),s(x,P,g),t(x,x)}const a=n(m,d);w&&T&&(o(m,m,w),o(d,d,w),o(x,x,T));const u=c+2*v,h=u+1;j.setVec(u,m),j.setVec(h,m),L.setVec(u,x),L.setVec(h,x),M.set(u,0,O),M.set(u,1,-1),M.set(h,0,O),M.set(h,1,1),v<f-1&&(O+=a)}const A=u.auxpos1;for(let e=0;e<2*f;++e)A.set(c+e,O)}}export{h as MeasurementArrowMaterial};
