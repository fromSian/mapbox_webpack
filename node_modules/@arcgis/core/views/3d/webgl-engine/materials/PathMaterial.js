/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{clamp as e}from"../../../../core/mathUtils.js";import{isNone as t}from"../../../../core/maybe.js";import{fromValues as r}from"../../../../geometry/support/aaBoundingBox.js";import{BufferViewVec4f as i}from"../../../../geometry/support/buffer/BufferView.js";import{newLayout as s}from"../../support/buffer/InterleavedLayout.js";import{computeAttachmentOriginLines as a}from"../lib/geometryDataUtils.js";import n from"../lib/GLMaterial.js";import{materialParametersDefaults as o,Material as u}from"../lib/Material.js";import{isPathGeometry as l}from"../lib/PathGeometry.js";import{assert as h}from"../lib/Util.js";import{pathVertexAttributeLocations as c,PathTechniqueConfiguration as p,PathTechnique as d}from"./PathTechnique.js";import f from"./VisualVariableMaterialParameters.js";import{writeDefaultAttributes as m,writeBufferVec4 as b}from"./internal/bufferWriterUtils.js";import{intersectAabbInvDir as v}from"./internal/MaterialUtil.js";const g=h;class S extends u{constructor(e){super(e,q),this.supportsEdges=!0,this._vertexAttributeLocations=c,this.techniqueConfig=new p,this.vertexBufferLayout=S.getVertexBufferLayout(this.parameters)}getTechniqueConfig(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.vvSize=this.parameters.vvSizeEnabled,this.techniqueConfig.vvColor=this.parameters.vvColorEnabled,this.techniqueConfig.vvOpacity=this.parameters.vvOpacityEnabled,this.techniqueConfig.slicePlaneEnabled=this.parameters.slicePlaneEnabled,this.techniqueConfig.transparent=this.parameters.transparent,this.techniqueConfig.sceneHasOcludees=this.parameters.sceneHasOcludees,0!==e&&7!==e||(this.techniqueConfig.doubleSidedMode=this.parameters.doubleSided&&"normal"===this.parameters.doubleSidedType?1:this.parameters.doubleSided&&"winding-order"===this.parameters.doubleSidedType?2:0,this.techniqueConfig.receiveShadows=this.parameters.receiveShadows,this.techniqueConfig.receiveSSAO=!!t.ssaoEnabled&&this.parameters.receiveSSAO),this.techniqueConfig.transparencyPassType=t.transparencyPassType,this.techniqueConfig.multipassTerrainEnabled=t.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=t.cullAboveGround,this.techniqueConfig}getPassParameters(){return this.parameters}isVisibleInPass(e){return 4!==e&&6!==e&&7!==e||this.parameters.castShadows}isVisible(){const e=this.parameters;return!!super.isVisible()&&e.opacity>0}intersect(i,s,a,n,o,u,h){const c=i;if(!l(c))return;const p=c.path,d=[this.parameters.size[0],this.parameters.size[1]];if(this.parameters.vvSizeEnabled){const t=this.parameters.vvSizeOffset,r=this.parameters.vvSizeFactor,i=this.parameters.vvSizeMinSize,s=this.parameters.vvSizeMaxSize,a=p.sizeAttributeValue;d[0]*=e(t[0]+a*r[0],i[0],s[0]),d[1]*=e(t[2]+a*r[2],i[2],s[2])}const f=Math.max(d[0],d[1]),m=i.boundingInfo;if(t(m))return void this._intersectTriangles(p,d,o,u,h);const b=r(m.bbMin[0]-f,m.bbMin[1]-f,m.bbMin[2]-f,m.bbMax[0]+f,m.bbMax[1]+f,m.bbMax[2]+f),g=[u[0]-o[0],u[1]-o[1],u[2]-o[2]],S=Math.sqrt(g[0]*g[0]+g[1]*g[1]+g[2]*g[2]),y=[S/g[0],S/g[1],S/g[2]];v(b,o,y,n.tolerance)&&this._intersectTriangles(p,d,o,u,h)}_intersectTriangles(e,t,r,i,s){e.baked.size&&e.baked.size[0]===t[0]&&e.baked.size[1]===t[1]||e.baked.bake(t),e.baked.intersect(r,i,s)}computeAttachmentOrigin(e,t){const r=e.vertexAttributes;if(!r)return null;const i=r.get("position");return a(i,null,!1,t)}createBufferWriter(){return new x(this.vertexBufferLayout)}requiresSlot(e){return e===(this.parameters.transparent?4:2)||20===e}createGLMaterial(e){return 0===e.output||7===e.output||1===e.output||2===e.output||4===e.output||3===e.output&&this.parameters.castShadows?new y(e):null}static getVertexBufferLayout(e){let t=s().vec3f("position").vec4f("profileRight").vec4f("profileUp").vec4f("profileVertexAndNormal");return(e.vvColorEnabled||e.vvSizeEnabled||e.vvOpacityEnabled)&&(t=t.vec4f("featureValue")),t}}class y extends n{updateParameters(e){return this.ensureTechnique(d,e)}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.sceneHasOcludees&&this._material.setParameters({sceneHasOcludees:e.hasOccludees})}_updateShadowState(e){(t(this.technique)||e.shadowMappingEnabled!==this.technique.configuration.receiveShadows)&&this._material.setParameters({receiveShadows:e.shadowMappingEnabled})}beginSlot(e){return 0!==this._output&&7!==this._output||(this._updateShadowState(e),this._updateOccludeeState(e)),this.updateParameters(e)}bind(e,t){t.bindPass(this._material.getPassParameters(),e)}}const q={size:[1,1,1],ambient:[.2,.2,.2],diffuse:[.8,.8,.8],specular:[0,0,0],opacity:1,doubleSided:!1,doubleSidedType:"normal",receiveSSAO:!0,receiveShadows:!1,castShadows:!0,slicePlaneEnabled:!1,transparent:!1,sceneHasOcludees:!1,...f.Default,...o};class x{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get("position").length}write(e,t,r,s){const a=e=>{if(t.vertexAttributes.has(e)){const a=t.vertexAttributes.get(e),n=t.indices.get(e);g(4===a.size);const o=r.getField(e,i);if(!o)throw new Error("unable to acquire view for "+e);b(n,a.data,o,s)}};a("profileRight"),a("profileUp"),a("profileVertexAndNormal"),this.vertexBufferLayout.hasField("featureValue")&&a("featureValue"),m(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,r,s)}}export{S as PathMaterial};
