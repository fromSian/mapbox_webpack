/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{lerp as t}from"../../../core/mathUtils.js";import{isSome as e}from"../../../core/maybe.js";import{c as n}from"../../../chunks/vec3f64.js";import{s as o}from"../../../chunks/vec4.js";import{c as r}from"../../../chunks/vec4f64.js";import{empty as s}from"../../../geometry/support/aaBoundingBox.js";import{BufferPool as i}from"../../../geometry/support/buffer/BufferPool.js";import{newLayout as c}from"../support/buffer/InterleavedLayout.js";import{ElevationData as u}from"./ElevationData.js";import{MAX_PATCH_TESSELATION as a,GEOMETRY_VERTEX_STRIDE as f}from"./TerrainConst.js";import{computeNormal as l}from"../webgl-engine/materials/internal/MaterialUtil.js";const m=c().vec3f("position").vec2f("uv0"),g=new i((t=>m.createBuffer(t)),(t=>t.count));class p{constructor(){this.indices=null,this.vertexAttributes=null,this.boundingBox=s(),this.numSurfaceIndices=0,this.numSkirtIndices=0,this.numWithoutSkirtIndices=0,this.numVertsPerRow=0,this.skirtLength=0,this.uvOffsetAndScale=r()}}class h{constructor(t,e,n){this.values=t,this.numSurfaceIndices=e,this.numSkirtIndices=n}}function y(){g.clear(),V.clear()}function d(t){g.release(t.vertexAttributes),t.vertexAttributes=null,t.indices=null}const w=65536;function I(e,n,r,i,c,a,l,m){const p=c[0],h=c[1],y=c[2],d=c[3],w=.1*l.radius*(d-h),I=e.numVertsPerRow-1,v=e.numVertsPerRow-1,V=e.numVertsPerRow*e.numVertsPerRow,x=2*I+2*v,b=g.acquire(V+x),R=b.position.typedBuffer,k=b.uv0.typedBuffer,j=i.geometryInfo.boundingBox;s(j);const L=n[2]-n[0],O=n[3]-n[1],U=y-p,E=r[0],N=r[1],W=r[2];for(let t=0;t<=I;t++){const e=t/I,o=p+e*U;B[t]=Math.sin(o),D[t]=Math.cos(o),T[t]=e,q[t]=n[0]+e*L}const C=a&&!!(1&m),F=a&&!!(2&m);let z=0;for(let o=0;o<=v;o++){let r=o/v;const s=t(h,d,r),i=Math.cos(s),c=Math.sin(s);let m;a?(m=l.halfSemiMajorAxis*Math.log((1+c)/(1-c)),r=(m-n[1])/O):m=180*s/Math.PI;for(let t=0;t<=I;t++){const n=T[t],s=B[t],a=D[t];let g=l.radius;e.samplerData&&(g+=u.sample(q[t],m,e.samplerData)||0);const p=a*i*g-E,h=s*i*g-N,y=c*g-W;P(p,h,y,j);const d=f*z;R[d+0]=p,R[d+1]=h,R[d+2]=y,k[d+0]=n,k[d+1]=r;const M=S(t,o,I,v);if(M>-1){const t=f*(V+M),e=C&&0===o?-1:F&&o===v?1:0,s=0===e?p:-E,i=0===e?h:-N,c=0===e?y:l.radius*e-W;R[t+0]=s,R[t+1]=i,R[t+2]=c,k[t+0]=0===e?A(n,r):n,k[t+1]=0===e?w:r,0!==e&&P(s,i,c,j)}++z}}i.geometryInfo.numVertsPerRow=e.numVertsPerRow,i.geometryInfo.vertexAttributes=b,i.geometryInfo.skirtLength=w,o(i.geometryInfo.uvOffsetAndScale,0,0,1,1),M(i.geometryInfo,e.numVertsPerRow,a?m:0,e.wireframe),i.intersectionData=null,i.skirtIntersectionData=null}function v(t,n,r,i,c){const a=n[0],l=n[1],m=n[2]-a,p=n[3]-l,h=t.clippingArea,y=e(h)?Math.max(0,(h[0]-n[0])/m):0,d=e(h)?Math.max(0,(h[1]-n[1])/p):0,w=e(h)?Math.min(1,(h[2]-n[0])/m):1,I=e(h)?Math.min(1,(h[3]-n[1])/p):1,v=w>y?1/(w-y):1,V=I>d?1/(I-d):1,x=-y*v,b=-d*V,R=m*i*.1,k=t.numVertsPerRow-1,j=t.numVertsPerRow-1,B=t.numVertsPerRow*t.numVertsPerRow,D=2*k+2*j,T=g.acquire(B+D),q=T.position.typedBuffer,L=T.uv0.typedBuffer,O=c.geometryInfo.boundingBox;s(O);let U=0;for(let o=0;o<=j;o++){const n=o/j;let s=b+n*V,c=l+n*p;e(h)&&(c<h[1]?(c=h[1],s=0):c>h[3]&&(c=h[3],s=1));for(let l=0;l<=k;l++){const n=l/k;let g=x+n*v,p=a+n*m;e(h)&&(p<h[0]?(p=h[0],g=0):p>h[2]&&(p=h[2],g=1));const y=t.samplerData&&u.sample(p,c,t.samplerData)||0,d=p*i-r[0],w=c*i-r[1],I=y-r[2];P(d,w,I,O);const V=f*U;q[V+0]=d,q[V+1]=w,q[V+2]=I,L[V+0]=g,L[V+1]=s;const M=S(l,o,k,k);if(M>-1){const t=f*(B+M);q[t+0]=d,q[t+1]=w,q[t+2]=I,L[t+0]=A(g,s),L[t+1]=R}++U}}c.geometryInfo.numVertsPerRow=t.numVertsPerRow,c.geometryInfo.vertexAttributes=T,c.geometryInfo.skirtLength=R,o(c.geometryInfo.uvOffsetAndScale,y,d,w-y,I-d),M(c.geometryInfo,t.numVertsPerRow,0,t.wireframe),c.intersectionData=null,c.skirtIntersectionData=null}const V=new Map;function M(t,e,n,o){const r=(2&n)>0,s=e+(o?1024:0)+(r?2048:0);let i=V.get(s);i||(i=x(e,r,o),V.set(s,i)),t.indices=i.values,t.numSurfaceIndices=i.numSurfaceIndices,t.numSkirtIndices=i.numSkirtIndices,t.numWithoutSkirtIndices=t.numSurfaceIndices+(n?6*(e-1)*(o?2:1):0)}function x(t,e,n){const o=t-1,r=t-1,s=t*t,i=2*o+2*r;let c=o*r*2*3,u=6*i,a=6*(2*o+r-1);n&&(c*=2,u*=2,a*=2);const f=s+i>w?new Uint32Array(c+u):new Uint16Array(c+u);let l,m,g,p,y=0,d=0,I=c,v=0;for(let h=0;h<=r;h++){e&&(v=0===h?a:h===r?-a:0),I+=v;for(let t=0;t<=o;t++){const e=S(t,h,o,r);if(e>-1){const i=b(t,h,o,r);0!==i&&(l=y,m=s+e,g=s+(0===t&&1===h?0:e+1),p=y+i,n?(f[I+0]=l,f[I+1]=m,f[I+2]=m,f[I+3]=g,f[I+4]=g,f[I+5]=l,f[I+6]=g,f[I+7]=p,f[I+8]=p,f[I+9]=l,f[I+10]=l,f[I+11]=g,I+=12):(f[I+0]=l,f[I+1]=m,f[I+2]=g,f[I+3]=g,f[I+4]=p,f[I+5]=l,I+=6))}++y,t<o&&h<r&&(l=h*(o+1)+t,m=l+1,g=m+(o+1),p=g-1,n?(f[d+0]=l,f[d+1]=m,f[d+2]=m,f[d+3]=g,f[d+4]=g,f[d+5]=l,f[d+6]=g,f[d+7]=p,f[d+8]=p,f[d+9]=l,f[d+10]=l,f[d+11]=g,d+=12):(f[d+0]=l,f[d+1]=m,f[d+2]=g,f[d+3]=g,f[d+4]=p,f[d+5]=l,d+=6))}I-=v}return new h(f,c,u)}function P(t,e,n,o){t<o[0]&&(o[0]=t),t>o[3]&&(o[3]=t),e<o[1]&&(o[1]=e),e>o[4]&&(o[4]=e),n<o[2]&&(o[2]=n),n>o[5]&&(o[5]=n)}function A(t,e){const n=e>t?1:0;return 2+4*n+(1-2*n)*(t+e)}function S(t,e,n,o){return 0===e?t:t===n?n+e:e===o?n+o+(n-t):0===t&&e>0?2*n+o+(o-e):-1}function b(t,e,n,o){return 0===e&&t!==n?1:t===n&&e!==o?n+1:e===o&&0!==t?-1:0===t&&0!==e?-(n+1):0}function R(t,n,o,r,s,i,c,u,a,f){const m=i.position,g=i.uv0,p=t[0],h=t[1],y=t[2],d=n[0]-p,w=n[1]-h,I=n[2]-y;r*=3;for(let v=o*=3;v<r;v+=3){const t=s[v],n=s[v+1],o=s[v+2];let r=m.get(t,0),i=m.get(t,1),V=m.get(t,2),M=m.get(n,0),x=m.get(n,1),P=m.get(n,2),A=m.get(o,0),S=m.get(o,1),b=m.get(o,2);if(g.get(t,0)>=2){const t=r+u[0],e=i+u[1],n=V+u[2],o=c/Math.sqrt(t*t+e*e+n*n);r+=t*o,i+=e*o,V+=n*o}if(g.get(n,0)>=2){const t=M+u[0],e=x+u[1],n=P+u[2],o=c/Math.sqrt(t*t+e*e+n*n);M+=t*o,x+=e*o,P+=n*o}if(g.get(o,0)>=2){const t=A+u[0],e=S+u[1],n=b+u[2],o=c/Math.sqrt(t*t+e*e+n*n);A+=t*o,S+=e*o,b+=n*o}e(a)&&([r,i,V]=a.applyToVertex(r,i,V),[M,x,P]=a.applyToVertex(M,x,P),[A,S,b]=a.applyToVertex(A,S,b));const R=M-r,k=x-i,j=P-V,B=A-r,D=S-i,T=b-V,q=w*T-D*I,O=I*B-T*d,U=d*D-B*w,E=R*q+k*O+j*U;if(Math.abs(E)<=Number.EPSILON)continue;const N=p-r,W=h-i,C=y-V,F=N*q+W*O+C*U;if(E>0){if(F<0||F>E)continue}else if(F>0||F<E)continue;const z=W*j-k*C,G=C*R-j*N,H=N*k-R*W,J=d*z+w*G+I*H;if(E>0){if(J<0||F+J>E)continue}else if(J>0||F+J<E)continue;const K=(B*z+D*G+T*H)/E;if(K>=0){f(K,l(R,k,j,B,D,T,L))}}}function k(t,e,n,o,r,s){const i=o.position,c=o.uv0,u=new Map,a=3*e,f=3*n-a,l=new Uint32Array(f);let m=0;for(let p=0;p<f;++p){const e=t[p+a];if(u.has(e))l[p]=u.get(e);else{const t=m++;u.set(e,t),l[p]=t}}const g=new Float64Array(3*m);return u.forEach(((t,e)=>{let n=i.get(e,0),o=i.get(e,1),u=i.get(e,2);if(c.get(e,0)>=2){const t=n+s[0],e=o+s[1],i=u+s[2],c=r/Math.sqrt(t*t+e*e+i*i);n+=t*c,o+=e*c,u+=i*c}g[3*t+0]=n,g[3*t+1]=o,g[3*t+2]=u})),{vertices:g,indices:l}}function j(t,n,o,r,s,i,c,u,a){const f=i.position,m=i.uv0,g=t[0],p=t[1],h=t[2],y=n[0]-g,d=n[1]-p,w=n[2]-h;r*=3;for(let I=o*=3;I<r;I+=3){const t=s[I],n=s[I+1],o=s[I+2];let r=f.get(t,0),i=f.get(t,1),v=f.get(t,2),V=f.get(n,0),M=f.get(n,1),x=f.get(n,2),P=f.get(o,0),A=f.get(o,1),S=f.get(o,2);m.get(t,0)>=2&&(v+=c);m.get(n,0)>=2&&(x+=c);m.get(o,0)>=2&&(S+=c),e(u)&&([r,i,v]=u.applyToVertex(r,i,v),[V,M,x]=u.applyToVertex(V,M,x),[P,A,S]=u.applyToVertex(P,A,S));const b=V-r,R=M-i,k=x-v,j=P-r,B=A-i,D=S-v,T=d*D-B*w,q=w*j-D*y,O=y*B-j*d,U=b*T+R*q+k*O;if(Math.abs(U)<=Number.EPSILON)continue;const E=g-r,N=p-i,W=h-v,C=E*T+N*q+W*O;if(U>0){if(C<0||C>U)continue}else if(C>0||C<U)continue;const F=N*k-R*W,z=W*b-k*E,G=E*R-b*N,H=y*F+d*z+w*G;if(U>0){if(H<0||C+H>U)continue}else if(H>0||C+H<U)continue;const J=(j*F+B*z+D*G)/U;if(J>=0){a(J,l(b,R,k,j,B,D,L))}}}const B=new Array(a+1),D=new Array(a+1),T=new Array(a+1),q=new Array(a+1),L=n();export{p as PatchGeometry,y as clearCaches,v as createPlanarGlobePatch,I as createSphericalGlobePatch,k as getGlobalSkirtGeometry,R as intersectSkirtsGlobal,j as intersectSkirtsLocal,d as releaseGeometry};
