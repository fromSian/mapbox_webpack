/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{equals as e}from"../../../core/arrayUtils.js";import{isSome as t,isNone as r,mapOr as i}from"../../../core/maybe.js";import{empty as s}from"../../../geometry/support/aaBoundingBox.js";import{glLayout as a}from"../support/buffer/glUtil.js";import{PatchGeometry as n,releaseGeometry as o}from"./PatchGeometryFactory.js";import l from"./TextureFader.js";import u from"./TileOverlayData.js";import{fallsWithinLayer as m}from"./tileUtils.js";import{Default3D as h}from"../webgl-engine/lib/DefaultVertexAttributeLocations.js";import c from"../../webgl/BufferObject.js";import g from"../../webgl/VertexArrayObject.js";class f{constructor(){this.geometryInfo=new n,this.intersectionData=null,this.skirtIntersectionData=null,this._textureRef=new l((()=>this.tile.surface.textureFadeDuration)),this.overlay=new u}init(e){this.tile=e,this.clear();const t=this.geometryInfo;t.indices=null,t.vertexAttributes=null,s(t.boundingBox),t.numSurfaceIndices=0,t.numSkirtIndices=0,t.numWithoutSkirtIndices=0,t.numVertsPerRow=0,this.intersectionData=null,this.skirtIntersectionData=null,this.geometryState={numVertsPerRow:0,samplerData:null,clippingArea:null,wireframe:!1},this.localOrigin=null,this.overlay.clear()}clear(){this.releaseGeometry(),this.releaseTexture(),this._textureRef.clear()}updateGeometry(e,t){return!!this._updateGeometryState(t)&&(this._releaseGeometry(),this._createGeometry(e),!0)}releaseGeometry(){return!!this._releaseGeometry()&&(this.geometryState={numVertsPerRow:0,samplerData:null,clippingArea:null,wireframe:!1},!0)}ensureTexture(e,i){return t(this._texture)&&this._texture.descriptor.width!==e&&this.releaseTexture(),r(this._texture)&&(this._texture=i(),this.tile.setMemoryDirty()),this._texture}releaseTexture(){t(this._texture)&&(this._texture.release(),this._texture=null,this.tile.setMemoryDirty())}_updateGeometryState(t){const r=this._getElevationInfo(),i=r.samplerData?this.tile.getElevationBasedVerticesPerRow(r.maxTileLevel):this.tile.getDefaultVerticesPerRowOnLevel();let s=this.tile.clippingArea;this.tile.intersectsClippingArea&&!this.tile.isWithinClippingArea||(s=null);const a=this.geometryState;let n=!1;return a.numVertsPerRow!==i&&(a.numVertsPerRow=i,n=!0),r.changed&&(a.samplerData=r.samplerData,n=!0),e(a.clippingArea,s)||(a.clippingArea=s,n=!0),a.wireframe!==t&&(a.wireframe=t,n=!0),n}_createGeometry(e){this.tile.createGeometry(this.geometryState,this.localOrigin);const t=this.geometryInfo.vertexAttributes,r=this.geometryInfo.indices,i=e.gl;this._vao=new g(e,h,{geometry:a(t.layout)},{geometry:c.createVertex(e,i.STATIC_DRAW,t.buffer)},c.createIndex(e,i.STATIC_DRAW,r))}_releaseGeometry(){return!!this._vao&&(this._vao.dispose(),this._vao=null,o(this.geometryInfo),!0)}get vao(){return this._vao}setTextureReference(e,r=0){t(e)&&e.texture!==this._texture&&this.releaseTexture(),this._textureRef.push(e,r)}get textureReference(){return this._textureRef.current}get nextTextureReference(){return this._textureRef.next}get textureFadeFactor(){return this._textureRef.fadeFactor}get textureIsFading(){return this._textureRef.isFading}_getElevationInfo(){const e=this.geometryState.samplerData,t=this.tile.layerInfo[0],r=t.length;let i=new Array(r),s=0,a=0,n=!1;for(let o=0;o<r;o++){const r=t[o];if(r.upsampleInfo){const t=r.upsampleInfo.tile,l=t.layerInfo[0][o].data,u=l&&l.samplerData;e&&e[s]===u||(n=!0),i[s++]=u,a=Math.max(a,t.lij[0])}else if(r.data){const t=this.tile.surface.layerViewByIndex(o,0);if(m(this.tile,t.layer,!1)){const t=r.data;e&&e[s]===t.samplerData||(n=!0),i[s++]=t.samplerData,a=this.tile.level}}}return e&&e.length!==s&&(n=!0),s>0?i.length=s:i=null,{changed:n,samplerData:i,maxTileLevel:a}}get estimatedGeometryMemoryUsage(){const e=i(this.intersectionData,0,(e=>e.estimatedMemoryUsage))+i(this.skirtIntersectionData,0,(e=>e.estimatedMemoryUsage+e.vertexPositionBuffer.byteLength));return this.geometryInfo.indices.byteLength+this.geometryInfo.vertexAttributes.byteLength+e}get textureDescriptor(){return t(this._texture)?this._texture.descriptor:null}get test(){return{hasTexture:null!=this._texture}}}export{f as PatchRenderData};
