/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import"../../../../geometry.js";import t from"../../../../core/Accessor.js";import s from"../../../../core/Evented.js";import n from"../../../../core/Handles.js";import{handlesGroup as i,makeHandle as r}from"../../../../core/handleUtils.js";import{isSome as o,isNone as a,unwrapOr as l,abortMaybe as c,removeMaybe as h,none as p}from"../../../../core/maybe.js";import{createTask as d,ignoreAbortErrors as u}from"../../../../core/promiseUtils.js";import{react as g,initial as y,syncAndInitial as _,sync as m}from"../../../../core/reactiveUtils.js";import{property as v}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/arrayUtils.js";import"../../../../core/has.js";import"../../../../core/accessorSupport/ensureType.js";import{subclass as f}from"../../../../core/accessorSupport/decorators/subclass.js";import{g as A,f as T,n as b,a as C,b as O,j as E,v as j}from"../../../../chunks/vec3.js";import{a as w,c as I}from"../../../../chunks/vec3f64.js";import{projectBoundingRect as S}from"../../../../geometry/projection.js";import{containsPointObject as P,empty as L}from"../../../../geometry/support/aaBoundingRect.js";import{fromPoints as R,create as V}from"../../../../geometry/support/ray.js";import{LineOfSightAnalysis as H}from"./LineOfSightAnalysis.js";import{LineOfSightRayIntersector as D}from"./LineOfSightRayIntersector.js";import{LineOfSightResult as x}from"./LineOfSightResult.js";import{getElevationAtPoint as N}from"../../support/ElevationProvider.js";import{toGraphic as k}from"../../webgl-engine/lib/intersectorUtilsConversions.js";import{ImmediateTask as F,TaskPriority as z}from"../../../support/Scheduler.js";import{WatchUpdatingTracking as G}from"../../../support/WatchUpdatingTracking.js";import U from"../../../../geometry/Point.js";let M=class extends(s.EventedMixin(t)){constructor(e){super(e),this._updatingHandles=new G,this._frameTask=F,this._handles=new n,this._analysisHandles=new n}initialize(){var e;const t=null==(e=this.view.resourceController)?void 0:e.scheduler;t&&(this._frameTask=t.registerTask(z.LINE_OF_SIGHT_TOOL)),this._handles.add([this._connectObserver(),this._connectAnalyses(),this._connectTargets()]),this._intersector=new D({view:this.view})}destroy(){this._handles.destroy(),this._analysisHandles.destroy(),this._analyses.removeAll(),this._updatingHandles.destroy()}get updating(){return this._frameTask.updating||this._updatingHandles.updating}get priority(){return this._frameTask.priority}set priority(e){this._frameTask.priority=e}get _analyses(){return this.analysisViewData.analyses}get _observerEngineLocation(){return this.analysisViewData.observerEngineLocation}set _observerEngineLocation(e){this.analysisViewData.observerEngineLocation=e}get _screenPixelSize(){return this.view.state.camera.computeScreenPixelSizeAt(this._observerEngineLocation)}getLineOfSightComputationDependencies(e){const{inputPoints:t}=e;return{inputPoints:t}}computeAnalysis(e){const t=e.analysis,{inputPoints:s,computationResult:n}=t,{observerAdjusted:i,targetAdjusted:r}=s,{start:o,end:a}=n;A(o,i),A(a,r);this._canComputeAnalysis(t)?this._computeAnalysisIntersection(e):this._interpolateAnalysisIntersection(e),t.updateComputationResults(),this.emit("result-changed",{target:e.analysis.target,result:t.result})}_adjustStartEndPositions(e){const t=this._screenPixelSize,s=this.view,{inputPoints:n}=e,{observer:i,observerSurfaceNormal:r,target:a,targetSurfaceNormal:l,observerAdjusted:c,targetAdjusted:h}=n,p=Z;o(r)?A(p,r):T(p,a,i);const d=t;b(p,p),C(p,p,Math.min(d,1)),O(c,i,p),o(l)?A(p,l):T(p,i,a);const u=s.state.camera.computeScreenPixelSizeAt(a);b(p,p),C(p,p,Math.min(u,1)),O(h,a,p)}_computeAnalysisIntersection({analysis:e,interpolationInfo:t}){const{view:s}=this,{sceneIntersectionHelper:n,renderCoordsHelper:i}=s;if(a(n))return;const r=this._intersector.intersector,{computationResult:l,inputPoints:c}=e,{observer:h,target:p}=c,{start:d,end:u}=l,g=R(d,u,J);n.intersectToolIntersectorRay(g,r);const y=l.intersection,_=Z,m=r.results.min.getIntersectionPoint(y);let v=!0;if(m){A(t.originalIntersection,y),A(t.originalObserver,d),A(t.originalTarget,u),i.fromRenderCoords(y,_,s.spatialReference);const e=1-E(u,p)/E(d,p);v=E(h,y)>=e*E(h,p)}const f=new U(_,s.spatialReference);{const{result:t,target:n}=e;o(t)?(t.target=n,t.intersectedGraphic=v?null:k(r.results.min,s),t.intersectedLocation=v?null:f,t.visible=!!m&&v):e.result=new x({target:n,elevationAlignedTargetLocation:e.elevationAlignedTargetLocation,intersectedGraphic:v?null:k(r.results.min,s),intersectedLocation:v?null:f,visible:!!m&&v})}l.isValid=c.isValid=!0,l.isTargetVisible=v}_interpolateAnalysisIntersection({analysis:e,interpolationInfo:t}){const{computationResult:s,inputPoints:n}=e,{start:i,end:r,intersection:o}=s,{originalIntersection:a,originalObserver:l,originalTarget:c}=t;if(A(o,a),n.isValid){const e=Z,t=E(l,a)/E(l,c);j(e,i,l),C(e,e,1-t),O(o,o,e),j(e,r,c),C(e,e,t),O(o,o,e),s.isValid=!0}else e.result=null,s.isValid=!1,s.isTargetVisible=!1}_canComputeAnalysis(e){const t=this.analysisViewData.elevationAlignedObserver,s=this.view.frustum;if(a(t)||a(e.target)||a(s))return!1;const{observerAdjusted:n,targetAdjusted:i}=e.inputPoints,r=s.intersectsPoint(n),o=s.intersectsPoint(i);return r&&o}_onObserverChange(e,t){if(a(e))return this.analysis.targets.removeAll(),void(this.analysisViewData.elevationAlignedObserver=null);this.analysisViewData.elevationAlignedObserver=this._applyElevationAlignment(e,t);const s=I();this.view.renderCoordsHelper.toRenderCoords(this.analysisViewData.elevationAlignedObserver,s),this._observerEngineLocation=s,this.priority=z.LINE_OF_SIGHT_TOOL_INTERACTIVE}_applyElevationAlignment(e,t){if(e.hasZ&&(a(t)||0===t.type))return e;const s=e.clone();return s.z=l(N(this.view.elevationProvider,s),0),s}_onObserverChangeForAnalysis(e){e.inputPoints.isValid=!1}_onObserverEngineForAnalysis(e,t,s){const{inputPoints:n}=e;if(A(n.observer,t),o(s)){const e=this._intersector.updateFromIntersectionResult(s);o(e)&&this.view.renderCoordsHelper.toRenderCoords(e,n.observer),n.observerSurfaceNormal=w(s.normal)}else n.observerSurfaceNormal=null;this._adjustStartEndPositions(e),e.updateInputPoints(),this.priority=z.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onTargetLocationChange(e,t,s){const n=e.inputPoints;if(n.isValid=!1,o(t)){if(e.elevationAlignedTargetLocation=this._applyElevationAlignment(t,s),this.view.renderCoordsHelper.toRenderCoords(e.elevationAlignedTargetLocation,n.target),o(s)){const e=this._intersector.updateFromIntersectionResult(s);o(e)&&this.view.renderCoordsHelper.toRenderCoords(e,n.target),n.targetSurfaceNormal=w(s.normal)}else n.targetSurfaceNormal=null;this._adjustStartEndPositions(e),e.updateInputPoints()}this.priority=z.LINE_OF_SIGHT_TOOL_INTERACTIVE}_connectAnalysisToTarget(e){return i([g((()=>e.target.location),(t=>{B(t,e.target.intersection)||(e.target.intersection=null)}),y),g((()=>({analysis:e,targetLocation:e.target.location,targetIntersection:e.target.intersection})),(({analysis:e,targetLocation:t,targetIntersection:s})=>{o(t)&&this._onTargetLocationChange(e,t,s)}),_)])}_connectAnalysisToObserver(e){return g((()=>({analysis:e,observer:this.analysisViewData.elevationAlignedObserver})),(({analysis:e})=>{this._onObserverChangeForAnalysis(e)}),_)}_connectAnalysisToObserverEngine(e){return g((()=>({analysis:e,observer:this._observerEngineLocation,observerIntersection:this.analysis.intersection})),(({analysis:e,observer:t,observerIntersection:s})=>{this._onObserverEngineForAnalysis(e,t,s)}),_)}_connectAnalysisToCamera(e){return g((()=>({camera:this.view.state.camera,isDirty:this._isCameraDirty})),(({isDirty:t})=>{e.inputPoints.isValid&&!t||e.updateInputPoints()}),m)}_connectAnalysisToElevation(e){return this.view.elevationProvider.on("elevation-change",(t=>{if(!this._canComputeAnalysis(e))return;const s=this.analysis.observer;q(t.extent,t.spatialReference,s)&&this._onObserverChange(s,this.analysis.intersection);const n=e.target;o(n)&&q(t.extent,t.spatialReference,n.location)&&e.onElevationChange()}))}_connectAnalysisForCompute(e){let t=p;const s={analysis:e,interpolationInfo:{originalIntersection:I(),originalObserver:I(),originalTarget:I()}};return i([g((()=>this.getLineOfSightComputationDependencies(e)),(()=>{t=c(t),t=d((async e=>{await u(this._frameTask.schedule((()=>this.computeAnalysis(s)),e))}))}),_),r((()=>t=c(t)))])}_connectAnalysis(e){const t=this._analysisHandles;t.has(e)||t.add([this._connectAnalysisToTarget(e),this._connectAnalysisToObserver(e),this._connectAnalysisToObserverEngine(e),this._connectAnalysisToCamera(e),this._connectAnalysisToElevation(e),this._connectAnalysisForCompute(e)],e)}_disconnectAnalysis(e){this._analysisHandles.remove(e)}_onAnalysesCollectionChange(e){e.added.forEach((e=>this._connectAnalysis(e))),e.removed.forEach((e=>this._disconnectAnalysis(e)))}_onTargetsChange(){return this._analyses.removeAll(),this.analysis.targets.forEach((e=>this._addTarget(e))),this._updatingHandles.addOnCollectionPropertyChange(this.analysis,"targets",(e=>this._onTargetCollectionChange(e)))}_onTargetCollectionChange(e){e.added.forEach((e=>this._addTarget(e))),e.removed.forEach((e=>this._removeTarget(e)))}_onCursorTargetChange(e,t){o(t)&&this._removeTarget(t),o(e)&&this._addTarget(e)}_addTarget(e){this._analyses.some((t=>t.target===e))||this._analyses.add(new H({target:e}))}_removeTarget(e){const t=this._analyses.find((t=>t.target===e));this._analyses.remove(t)}_connectObserver(){return i([g((()=>this.analysis.observer),(e=>{B(e,this.analysis.intersection)||(this.analysis.intersection=null)}),y),g((()=>({observer:this.analysis.observer,intersection:this.analysis.intersection})),(({observer:e,intersection:t})=>this._onObserverChange(e,t)),_)])}_connectAnalyses(){let e=null;return i([g((()=>this._analyses),(()=>{h(e),e=this._updatingHandles.addOnCollectionPropertyChange(this,"_analyses",(e=>this._onAnalysesCollectionChange(e))),this._analyses.forEach((e=>this._connectAnalysis(e)))}),_),r((()=>e=h(e)))])}_connectTargets(){let e=null;return i([g((()=>this.analysis.targets),(()=>{e=h(e),e=this._onTargetsChange()}),_),g((()=>this.analysisViewData.cursorTarget),((e,t)=>{this._onCursorTargetChange(e,t)})),r((()=>{e=h(e)}))])}get _isCameraDirty(){const e=this.analysisViewData.elevationAlignedObserver,{view:t}=this,{renderCoordsHelper:s}=t;if(a(e)||a(s))return!1;const n=Z;s.toRenderCoords(e,n);const i=t.state.camera.computeScreenPixelSizeAt(n);return Math.abs((i-this._screenPixelSize)/this._screenPixelSize)>W}};function q(e,t,s){return!a(s)&&(S(e,t,K,s.spatialReference),P(K,s))}function B(e,t){return a(t)||o(e)&&e.equals(t.point)}e([v({constructOnly:!0})],M.prototype,"analysis",void 0),e([v({constructOnly:!0})],M.prototype,"analysisViewData",void 0),e([v({constructOnly:!0})],M.prototype,"view",void 0),e([v()],M.prototype,"updating",null),e([v()],M.prototype,"priority",null),e([v()],M.prototype,"_analyses",null),e([v()],M.prototype,"_observerEngineLocation",null),e([v()],M.prototype,"_screenPixelSize",null),e([v({readOnly:!0})],M.prototype,"_updatingHandles",void 0),e([v()],M.prototype,"_frameTask",void 0),e([v()],M.prototype,"_isCameraDirty",null),M=e([f("esri.views.3d.analysis.LineOfSight.LineOfSightController")],M);const W=.1,Z=I(),J=V(),K=L();export{M as LineOfSightController};
