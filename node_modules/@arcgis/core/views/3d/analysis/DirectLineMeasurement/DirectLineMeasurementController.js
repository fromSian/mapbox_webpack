/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import t from"../../../../core/Accessor.js";import i from"../../../../core/Handles.js";import{deg2rad as s,rad2deg as o,acosClamped as r}from"../../../../core/mathUtils.js";import{destroyMaybe as a,isNone as n,unwrapOr as c}from"../../../../core/maybe.js";import l from"../../../../core/Quantity.js";import{react as d,syncAndInitial as m}from"../../../../core/reactiveUtils.js";import{whenOnce as p}from"../../../../core/watchUtils.js";import{property as h}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/arrayUtils.js";import"../../../../core/has.js";import"../../../../core/accessorSupport/ensureType.js";import{subclass as u}from"../../../../core/accessorSupport/decorators/subclass.js";import{i as v}from"../../../../chunks/vec3.js";import{c as g}from"../../../../chunks/vec3f64.js";import{geodesicLength as f}from"../../../../geometry/geometryEngine.js";import _ from"../../../../geometry/Polyline.js";import{canProjectWithoutEngine as w,projectPointToVector as D,projectPointToWGS84ComparableLonLat as y}from"../../../../geometry/projection.js";import{getSphericalPCPF as P,getReferenceEllipsoid as j,SphericalECEFSpatialReference as z,WGS84ECEFSpatialReference as A}from"../../../../geometry/projectionEllipsoid.js";import{isSupported as b,geodesicLengths as M,inverseGeodeticSolver as k}from"../../../../geometry/support/geodesicUtils.js";import{UnitNormalizer as E}from"../support/UnitNormalizer.js";import{getElevationAtPoint as R}from"../../support/ElevationProvider.js";const G=1e5;let S=class extends t{constructor(e){super(e),this._unitNormalizer=new E,this._handles=new i,this._tempStartPosition=g(),this._tempEndPosition=g(),this._tempCornerPosition=g()}initialize(){this._handles.add(p(this.view,"ready",(()=>this._initialize()),!0))}destroy(){this._handles=a(this._handles)}_initialize(){const e=this.view.spatialReference,t=P(e),i=t===z?A:t;this._sphericalPCPF=i;const s=w(e,i);this._unitNormalizer.spatialReference=s?i:e,this._handles.add([d((()=>({viewData:this.viewData,startPoint:this.analysis.startPoint})),(({viewData:e,startPoint:t})=>{e.elevationAlignedStartPoint=this._applyElevationAlignment(t)}),m),d((()=>({viewData:this.viewData,endPoint:this.analysis.endPoint})),(({viewData:e,endPoint:t})=>{e.elevationAlignedEndPoint=this._applyElevationAlignment(t)}),m),d((()=>({result:this._computedResult,viewData:this.viewData})),(({result:e,viewData:t})=>{t.result=e}),m)])}_applyElevationAlignment(e){if(n(e)||e.hasZ)return e;const t=e.clone();return t.z=c(R(this.view.elevationProvider,t),0),t}get _computedResult(){const{elevationAlignedStartPoint:e,elevationAlignedEndPoint:t}=this.viewData;if(n(e)||n(t))return null;const i=this._euclideanDistances(e,t),s=this._exactGeodesicDistanceAndAngle(e,t,i.horizontal.value);let o=null;switch(this.viewData.measurementMode){case 0:{var r;o="euclidean";const e=this.viewData.unit,t=(null==(r=i.horizontal)?void 0:r.value)>G;("degrees"===e||"degrees-minutes-seconds"===e||t)&&(o="geodesic");break}case 1:o="euclidean";break;case 2:o="geodesic"}return{distance:"euclidean"===o?i.direct:s.distance,mode:o,directDistance:i.direct,horizontalDistance:i.horizontal,verticalDistance:i.vertical,geodesicDistance:s.distance,geodesicAngle:s.angle}}_euclideanDistances(e,t){const i=e.clone();i.z=t.z;const s=this._tempStartPosition,o=this._tempEndPosition,r=this._tempCornerPosition,a=this.view.spatialReference,n=this._sphericalPCPF,c=w(a,n)?n:a;D(e,s,c),D(t,o,c),D(i,r,c);const d=v(s,o),m=v(r,o),p=Math.abs(t.z-e.z),h=e=>this._unitNormalizer.normalizeDistance(e),u=h(d),g=h(m),f=h(p);return{direct:new l(u,"meters"),horizontal:new l(g,"meters"),vertical:new l(f,"meters")}}_exactGeodesicDistanceAndAngle(e,t,i){const s=e.spatialReference,o=new _({spatialReference:s});o.addPath([e,t]);const r=s.isGeographic&&b(s)?M([o],"meters")[0]:s.isWebMercator?f(o,"meters"):void 0,{distance:a,angle:n}=r?{distance:r,angle:this._fallbackGeodesicAngle(r,s)}:this._fallbackGeodesicDistance(e,t,i);return{distance:new l(a,"meters"),angle:new l(n,"degrees")}}_fallbackGeodesicAngle(e,t){return e/j(t).metersPerDegree}_fallbackGeodesicDistance(e,t,i){if(y(e,U)){y(t,C);const e=s(U[0]),i=s(U[1]),a=s(C[0]),n=s(C[1]),c=Math.abs(a-e),l=r(Math.sin(i)*Math.sin(n)+Math.cos(i)*Math.cos(n)*Math.cos(c)),d=o(l),m={distance:0};return k(m,[U[0],U[1]],[C[0],C[1]]),{distance:m.distance,angle:d}}const a=e.spatialReference,n=i;return{distance:n,angle:this._fallbackGeodesicAngle(n,a)}}};e([h()],S.prototype,"view",void 0),e([h()],S.prototype,"analysis",void 0),e([h()],S.prototype,"viewData",void 0),e([h()],S.prototype,"_computedResult",null),S=e([u("esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementController")],S);const U=g(),C=g();export{S as DirectLineMeasurementController};
