/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import i from"../../../../../core/has.js";import{clamp as e}from"../../../../../core/mathUtils.js";import{createScreenPointArray as r}from"../../../../../core/screenUtils.js";import{property as s}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/accessorSupport/ensureType.js";import{subclass as a}from"../../../../../core/accessorSupport/decorators/subclass.js";import{c as n}from"../../../../../chunks/vec2.js";import{a as o}from"../../../../../chunks/vec2f64.js";import{n as c,a as h,b as m,f as p,l}from"../../../../../chunks/vec3.js";import{c as u}from"../../../../../chunks/vec3f64.js";import{getReferenceEllipsoid as y}from"../../../../../geometry/projectionEllipsoid.js";import{create as C,fromPoints as f}from"../../../../../geometry/support/axisAngle.js";import{c as P}from"../../../../../chunks/sphere.js";import{pixelDistanceToInteractionFactor as d,applyAll as g}from"../../../camera/constraintUtils.js";import{InteractiveController as v}from"../InteractiveController.js";import{normalizeCoordinate as j,pickPointAndInitSphere as R,decideNavigationMode as k,NavigationMode as w,DISTANCE_CLAMP_VALUES as D,PIVOT_DISTANCE_MODIFIER as A,SCREEN_PIXEL_AREA as b,sphereOrPlanePointFromScreenPoint as x,applyRotation as M}from"../../utils/navigationUtils.js";import{fromScreenAtEye as O}from"../../../support/geometryUtils/ray.js";import{applySurfaceCollisionConstraint as S}from"../../../camera/constraintUtils/surfaceCollision.js";let z=class extends v{constructor(t){super(t),this.view=null,this.pickPoint=u(),this.tmpP0=o(),this.panAxisAngle=C(),this.tmpRayDir=u(),this.targetOnSphere=u(),this.tmpRay={origin:u(),direction:u()},this.dragBeginPoint=r(),this.normalizedAnchorPoint=o(),this.constraintOptions={selection:7,interactionType:1,interactionFactor:0,interactionStartCamera:null,interactionDirection:null,tiltMode:0},this.sphere=P(),this.hasPickPoint=!1}get intersectionHelper(){return this.view.sceneIntersectionHelper}begin(t){if(!this.active)return;n(this.dragBeginPoint,t),j(this.startCamera,t,this.normalizedAnchorPoint);const r=y(this.view.spatialReference),s=R(this.intersectionHelper,this.startCamera,t,!1,r);if(this.navMode=k(this.startCamera,t,s.hasGeometryIntersection,r),this.navMode===w.Horizontal||i("disable-feature:context-navigation"))this.hasPickPoint=!!s.scenePickPoint,this.pickPoint=s.scenePickPoint,this.sphere=s.sphere;else{let i;O(this.startCamera,t,this.tmpRay),c(this.tmpRay.direction,this.tmpRay.direction),this.view.camera.position.hasZ&&(i=Math.abs(this.view.camera.position.z));let r=e(A*i,D[0],D[1]);const s=this.view._stage.renderView.getMinimalDepthForArea(null,t[0],t[1],this.view.state.camera,b);r=r>s?s:r,this.hasPickPoint=!0,h(this.tmpRay.direction,this.tmpRay.direction,r),m(this.pickPoint,this.tmpRay.origin,this.tmpRay.direction)}this.constraintOptions.interactionStartCamera=this.startCamera}update(t){if(this.active){if(this.currentCamera.eye=this.startCamera.eye,this.currentCamera.center=this.startCamera.center,this.currentCamera.up=this.startCamera.up,this.navMode===w.Horizontal||i("disable-feature:context-navigation")){p(this.tmpRayDir,this.currentCamera.center,this.currentCamera.eye);const i=l(this.tmpRayDir);j(this.currentCamera,t,this.tmpP0);const e=12*(this.normalizedAnchorPoint[1]-this.tmpP0[1]);let r=i*2**e;const s=this.view.state.constraints.minimumPoiDistance;if(e<0&&r<s&&(r=s),Math.abs(i-r)<1e-6)return;if(this.hasPickPoint&&r<i){const t=1-(1-r/i)*(1-this.sphere[3]/l(this.currentCamera.center));this.currentCamera.center=h(U,this.currentCamera.center,t)}h(this.tmpRayDir,this.tmpRayDir,-r/i),this.currentCamera.eye=m(U,this.currentCamera.center,this.tmpRayDir),this.constraintOptions.interactionFactor=d(this.dragBeginPoint,t),g(this.view,this.currentCamera,this.constraintOptions),this.hasPickPoint&&(x(this.sphere,this.currentCamera,this.dragBeginPoint,this.targetOnSphere),f(this.pickPoint,this.targetOnSphere,this.panAxisAngle),M(this.currentCamera,this.sphere,this.panAxisAngle))}else{const i=l(this.tmpRay.direction);j(this.currentCamera,t,this.tmpP0);const e=12*(this.normalizedAnchorPoint[1]-this.tmpP0[1]);let r=i*2**e;const s=this.view.state.constraints.minimumPoiDistance;if(e<0&&r<s&&(r=s),Math.abs(i-r)<1e-6)return;h(this.tmpRayDir,this.tmpRay.direction,1-r/i),this.currentCamera.eye=m(U,this.currentCamera.eye,this.tmpRayDir),this.currentCamera.center=m(U,this.currentCamera.center,this.tmpRayDir)}S(this.view,this.currentCamera)}}end(){this.active&&this.finishController()}};t([s({constructOnly:!0})],z.prototype,"view",void 0),z=t([a("esri.views.3d.state.controllers.global.ZoomController")],z);const U=u();export{z as ZoomController};
