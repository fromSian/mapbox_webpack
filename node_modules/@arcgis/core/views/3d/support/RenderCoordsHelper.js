/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{isSome as t}from"../../../core/maybe.js";import{getMetersPerUnitForSR as e}from"../../../core/unitUtils.js";import{s}from"../../../chunks/mat4.js";import{g as r}from"../../../chunks/vec3.js";import{projectPointToVector as i,projectVectorToVector as o,projectVectorToDehydratedPoint as n,projectVectorToPoint as a}from"../../../geometry/projection.js";import c from"../../../geometry/SpatialReference.js";import{create as m,setExtent as d,altitudeAt as l,setAltitudeAt as h,setAltitudeOfTransformation as u,normalAt as p,axisAt as f,elevate as y,intersectRayClosestSilhouette as S,intersectRay as g,createGlobal as j,createLocal as R,renderSRFromViewSR as w}from"../../../geometry/support/coordinateSystem.js";import{intersectRay as A}from"../../../geometry/support/plane.js";import{sv3d as M}from"../../../geometry/support/vectorStacks.js";import{isDehydratedPoint as _}from"../../../layers/graphics/dehydratedFeatureUtils.js";import{isSpatialReferenceSupported as P}from"../../support/spatialReferenceSupport.js";class v{constructor(t,e,s,r){this.viewingMode=t,this.spatialReference=e,this.unitInMeters=s,this.coordinateSystem=r,this._coordinateSystem=m(r)}set extent(t){t&&d(this.coordinateSystem,t,this.coordinateSystem)}getAltitude(t){return l(this.coordinateSystem,t)}setAltitude(t,e,s=t){return h(this.coordinateSystem,s,e,t)}setAltitudeOfTransformation(t,e){u(this.coordinateSystem,e,t,e)}worldUpAtPosition(t,e){return p(this.coordinateSystem,t,e)}worldBasisAtPosition(t,e,s){return f(this.coordinateSystem,t,e,s)}basisMatrixAtPosition(t,e){const r=this.worldBasisAtPosition(t,0,M.get()),i=this.worldBasisAtPosition(t,1,M.get()),o=this.worldBasisAtPosition(t,2,M.get());return s(e,r[0],r[1],r[2],0,i[0],i[1],i[2],0,o[0],o[1],o[2],0,0,0,0,1),e}intersectManifoldClosestSilhouette(t,e,s){return y(this.coordinateSystem,e,this._coordinateSystem),S(this._coordinateSystem,t,s),s}intersectManifold(t,e,s){y(this.coordinateSystem,e,this._coordinateSystem);const i=M.get();return g(this._coordinateSystem,t,i)?r(s,i):null}intersectInfiniteManifold(t,e,s){if(1===this.viewingMode)return this.intersectManifold(t,e,s);y(this.coordinateSystem,e,this._coordinateSystem);const i=this._coordinateSystem.value,o=M.get();return A(i.plane,t,o)?r(s,o):null}toRenderCoords(t,e,s){return _(t)?i(t,e,this.spatialReference):o(t,e,s,this.spatialReference)}fromRenderCoords(e,s,r=null){return _(s)?(t(r)&&(s.spatialReference=r),n(e,this.spatialReference,s)):s instanceof c?a(e,this.spatialReference,s):o(e,this.spatialReference,s,r)?s:null}static create(t,s){switch(t){case 2:return new v(2,s,e(s),R());case 1:return new v(1,s,1,j(s))}}static renderUnitScaleFactor(t,e){return B(t)/B(e)}}function B(t){if(P(t,1))return 1;const s=w(!1,t);return e(s)}export{v as RenderCoordsHelper};
