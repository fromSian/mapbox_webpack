/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{get as t,isSome as s,isNone as r}from"../../../../core/maybe.js";import{e as n}from"../../../../chunks/earcut.js";import{a as o}from"../../../../chunks/mat3.js";import{c as a}from"../../../../chunks/mat3f64.js";import{b as i}from"../../../../chunks/mat4.js";import{I as l,c}from"../../../../chunks/mat4f64.js";import{g as h,n as m,s as p,f as d,c as u,m as f}from"../../../../chunks/vec3.js";import{d as g,c as y}from"../../../../chunks/vec3f64.js";import{computeTranslationToOriginAndRotation as _}from"../../../../geometry/projection.js";import{create as b,empty as E,expandWithBuffer as x,intersectsClippingArea as v}from"../../../../geometry/support/aaBoundingBox.js";import{BufferViewVec3f64 as P}from"../../../../geometry/support/buffer/BufferView.js";import{t as w,a as j}from"../../../../chunks/vec32.js";import{getDriverAxisSizeValue as A}from"../../../../renderers/support/renderingInfoUtils.js";import{needsElevationUpdates3D as S,evaluateElevationInfoAtPoint as L,SampleElevationInfo as B}from"./elevationAlignmentUtils.js";import{ElevationContext as M}from"./ElevationContext.js";import{Graphics3DObject3DGraphicLayer as C}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as z}from"./Graphics3DSymbolLayer.js";import{validateSymbolLayerSize as R,computeCentroid as D}from"./graphicUtils.js";import{geometryAsPolygon as G,geometryToRenderInfo as I}from"./polygonUtils.js";import{createMaterial as T}from"../support/edgeUtils.js";import U from"../../support/debugFlags.js";import{SamplePosition as O}from"../../support/ElevationProvider.js";import{Geometry as k}from"../../webgl-engine/lib/Geometry.js";import{Object3D as F}from"../../webgl-engine/lib/Object3D.js";import{DefaultMaterial as H}from"../../webgl-engine/materials/DefaultMaterial.js";const N=["polygon","extent"];class V extends z{constructor(e,t,s,r){super(e,t,s,r),this.ensureDrapedStatus(!1)}async doLoad(){if(!this._drivenProperties.size){const t=R(this._getSymbolSize());if(t)throw new e("graphics3dextrudesymbollayer:invalid-size",t)}const s=t(this.symbolLayer,"material","color"),r=this._getCombinedOpacityAndColor(s),n=g(r),o=r[3],a=o<1||this.needsDrivenTransparentPass,i={usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0,diffuse:n,ambient:n,opacity:o,transparent:a,cullFace:a?0:2,vertexColors:!0,slicePlaneEnabled:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,offsetTransparentBackfaces:!0};this._material=new H(i),this._bottomMaterial=new H({...i,cullFace:2}),this._context.stage.add(this._material),this._context.stage.add(this._bottomMaterial)}destroy(){super.destroy(),this._material&&(this._context.stage.remove(this._material),this._context.stage.remove(this._bottomMaterial))}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,N,this.symbolLayer.type))return null;const s=this._getVertexOpacityAndColor(e.renderingInfo,255),r=this.setGraphicElevationContext(t,new M);return this._createAs3DShape(t,e.renderingInfo,s,r,t.uid)}layerOpacityChanged(e,r){const n=t(this.symbolLayer,"material","color"),o=this._getCombinedOpacity(n),a=o<1||this.needsDrivenTransparentPass;this._material.setParameters({opacity:o,transparent:a}),this._bottomMaterial.setParameters({opacity:o,transparent:a});const i=this._getLayerOpacity();return e.forEach((e=>{const t=r(e);s(t)&&t.layerOpacityChanged(i,this._context.isAsync)})),!0}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,S)}slicePlaneEnabledChanged(e,t){return this._material.setParameters({slicePlaneEnabled:this._context.slicePlaneEnabled}),this._bottomMaterial.setParameters({slicePlaneEnabled:this._context.slicePlaneEnabled}),e.forEach((e=>{const r=t(e);s(r)&&r.slicePlaneEnabledChanged(this._context.slicePlaneEnabled,this._context.isAsync)})),!0}physicalBasedRenderingChanged(){return this._material.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._bottomMaterial.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0}pixelRatioChanged(){return!0}_getExtrusionSize(e){let t;var s;e.size&&this._drivenProperties.size?t=null!=(s=A(e.size,2))?s:0:t=this._getSymbolSize();return t/=this._context.renderCoordsHelper.unitInMeters,t}applyRendererDiff(){return 1}_getSymbolSize(){var e;return null!=(e=this.symbolLayer.size)?e:1}_createAs3DShape(e,t,h,m,p){const d=G(e.geometry);if(r(d))return null;const u=I(d,this._context.elevationProvider,this._context.renderCoordsHelper,m);if(this._logGeometryCreationWarnings(u,d.rings,"rings","ExtrudeSymbol3DLayer"),0===d.rings.length||!d.rings.some((e=>e.length>0)))return null;const f=D(d);if(r(f))return null;const g=new Array,A=new Array,L=new Array,B=b(),M=c(),z=y(),R=1===this._context.renderCoordsHelper.viewingMode;R||this._context.renderCoordsHelper.worldUpAtPosition(null,z),_(d.spatialReference,[f.x,f.y,0],M,this._context.renderCoordsHelper.spatialReference);const U=c();i(U,M);const O=a();o(O,U);const{polygons:k,mapPosition:H,position:N}=u,V=N.length/3,W=new Float64Array(3*V*6),Z=new Float64Array(3*V*6),q=new Float64Array(3*V*6),J=new Float64Array(1*V*6);let K=0;for(let s=0;s<k.length;++s){const e=k[s],r=e.count;if(this._context.clippingExtent&&(E(B),x(B,e.mapPosition),!v(B,this._context.clippingExtent)))continue;const o=n(e.mapPosition,e.holeIndices,3);if(0===o.length)continue;const a=3*r*2+o.length,i=new Uint32Array(a),c=new Uint32Array(o.length),m=6*r,p=3*W.BYTES_PER_ELEMENT,d=new P(W.buffer,K*p,p,(K+m)*p),u=3*Z.BYTES_PER_ELEMENT,f=new P(Z.buffer,K*u,u,(K+m)*u),y=new Float64Array(q.buffer,3*K*q.BYTES_PER_ELEMENT,3*m),_=new Float64Array(J.buffer,1*K*J.BYTES_PER_ELEMENT,1*m),b=this._getExtrusionSize(t);Y(N,H,o,e,d.typedBuffer,y,f.typedBuffer,_,0,i,c,b,z,R),w(d,d,U),j(f,f,O),K+=6*r;const S=this._createExtrudeGeometry(i,i.length-c.length,{positions:d.typedBuffer,elevation:y,normals:f.typedBuffer,heights:_},h);g.push(S),A.push(this._material),L.push(l);const M=this._createExtrudeGeometry(c,0,{positions:d.typedBuffer,elevation:y,normals:f.typedBuffer,heights:_},h);g.push(M),A.push(this._bottomMaterial),L.push(l)}if(0===g.length)return null;const Q=new F({geometries:g,materials:A,transformations:L,metadata:{layerUid:this._context.layer.uid,graphicUid:p,isElevationSource:!0}});Q.transformation=M;const X=T(this.symbolLayer,{opacity:this._getLayerOpacity()}),$=s(X)?{baseMaterial:this._material,edgeMaterials:[X],properties:{mergeGeometries:!0,slicePlaneEnabled:this._context.slicePlaneEnabled}}:null,ee=new C(this,Q,g,null,null,re,m,$);return ee.alignedSampledElevation=u.sampledElevation,ee.needsElevationUpdates=S(m.mode),ee}_createExtrudeGeometry(e,t,s,r){const n=new Uint32Array(e.length),o=[["position",{size:3,data:s.positions,exclusive:!0}],["normal",{size:3,data:s.normals,exclusive:!0}],["color",{size:4,data:r,exclusive:!0}],["size",{size:1,data:s.heights,exclusive:!0}]],a=[["position",e],["normal",e],["color",n]];return s.elevation&&(o.push(["mapPos",{size:3,data:s.elevation}]),a.push(["mapPos",e])),new k(o,a,0,t)}}function Y(e,t,s,r,n,o,a,i,l,c,h,m,p,d){const u=s.length/3;let f=0,g=2*r.count;W(e,t,r.index,r.count,s,0,u,n,o,a,i,l,c,h,g,m,p,d),l+=2*r.count,g=0,J(n,o,i,a,f,r.pathLengths[0],r.count,l,c,g,m),l+=4*r.pathLengths[0],g+=2*r.pathLengths[0],f+=r.pathLengths[0];for(let y=1;y<r.pathLengths.length;++y)J(n,o,i,a,f,r.pathLengths[y],r.count,l,c,g,m),l+=4*r.pathLengths[y],g+=2*r.pathLengths[y],f+=r.pathLengths[y]}function W(e,t,s,r,n,o,a,i,l,c,p,d,u,f,g,y,_,b){h(oe,_);const E=y>0?1:-1;let x=3*s,v=d,P=3*v,w=d+r,j=3*w;for(let h=0;h<r;++h)b&&(oe[0]=e[x+0],oe[1]=e[x+1],oe[2]=e[x+2],m(oe,oe)),i[P+0]=e[x+0],i[P+1]=e[x+1],i[P+2]=e[x+2],l[P+0]=t[x+0],l[P+1]=t[x+1],l[P+2]=t[x+2],c[P+0]=-E*oe[0],c[P+1]=-E*oe[1],c[P+2]=-E*oe[2],p[v]=0,i[j+0]=e[x+0]+y*oe[0],i[j+1]=e[x+1]+y*oe[1],i[j+2]=e[x+2]+y*oe[2],l[j+0]=t[x+0],l[j+1]=t[x+1],l[j+2]=t[x+2],c[j+0]=E*oe[0],c[j+1]=E*oe[1],c[j+2]=E*oe[2],p[w]=y,P+=3,j+=3,x+=3,v+=1,w+=1;x=3*o,P=0,j=3*g;const A=y<0?le:ie,S=y<0?ie:le;for(let h=0;h<a;++h)f[P+0]=n[x+A[0]],f[P+1]=n[x+A[1]],f[P+2]=n[x+A[2]],u[j+0]=n[x+S[0]]+r,u[j+1]=n[x+S[1]]+r,u[j+2]=n[x+S[2]]+r,P+=3,j+=3,x+=3}function Z(e,t,s,r,n,o,a){r[o]=r[a],a*=3,e[(o*=3)+0]=e[a+0],e[o+1]=e[a+1],e[o+2]=e[a+2],t[o+0]=t[a+0],t[o+1]=t[a+1],t[o+2]=t[a+2],s[o+0]=n[0],s[o+1]=n[1],s[o+2]=n[2]}const q=y();function J(e,t,s,r,n,o,a,i,l,c,h){let m=n,p=n+1,d=n+a,u=n+a+1,f=i,g=i+1,y=i+2*o,_=i+2*o+1;h<0&&(m=n+a+1,u=n),c*=3;for(let b=0;b<o;++b)b===o-1&&(h>0?(p=n,u=n+a):(p=n,m=n+a)),te(e,m,p,d,q),Z(e,t,r,s,q,f,m),Z(e,t,r,s,q,g,p),Z(e,t,r,s,q,y,d),Z(e,t,r,s,q,_,u),l[c++]=f,l[c++]=y,l[c++]=_,l[c++]=f,l[c++]=_,l[c++]=g,m++,p++,d++,u++,f+=2,g+=2,y+=2,_+=2}const K=y(),Q=y(),X=y(),$=y(),ee=y();function te(e,t,s,r,n){t*=3,s*=3,r*=3,p(K,e[t++],e[t++],e[t++]),p(Q,e[s++],e[s++],e[s++]),p(X,e[r++],e[r++],e[r++]),d($,Q,K),d(ee,X,K),u(n,ee,$),m(n,n)}const se=y();function re(e,t,s,r){const n=e.stageObject,o=n.geometryRecords,a=o.length,l="absolute-height"!==t.mode;let h=0;const m=n.transformation,d=i(c(),m);for(let i=0;i<a;i+=2){const e=o[i].geometry,a=e.getMutableAttribute("position").data,c=e.vertexAttributes.get("size").data,u=e.vertexAttributes.get("mapPos").data,g=new O(u),y=a.length/3;let _=0,b=!1,E=0;const x=s.spatialReference;for(let n=0;n<y;n++){se[0]=a[_],se[1]=a[_+1],se[2]=a[_+2],L(g,s,t,r,ae),l&&(E+=ae.sampledElevation),U.TESTS_DISABLE_OPTIMIZATIONS?(p(ne,g.array[g.offset+0],g.array[g.offset+1],ae.z+c[_/3]),r.toRenderCoords(ne,x,ne),f(ne,ne,d)):(p(ne,a[_+0],a[_+1],a[_+2]),f(ne,ne,m),r.setAltitude(ne,ae.z+c[_/3]),f(ne,ne,d)),a[_]=ne[0],a[_+1]=ne[1],a[_+2]=ne[2];const e=ce/r.unitInMeters;(Math.abs(se[0]-a[_])>=e||Math.abs(se[1]-a[_+1])>=e||Math.abs(se[2]-a[_+2])>=e)&&(b=!0),g.offset+=3,_+=3}b&&(e.invalidateBoundingInfo(),n.geometryVertexAttrsUpdated(o[i]),o[i+1].geometry.invalidateBoundingInfo(),n.geometryVertexAttrsUpdated(o[i+1])),h+=E/y}return h/a}const ne=y(),oe=y(),ae=new B,ie=[0,2,1],le=[0,1,2],ce=.01;export{V as Graphics3DExtrudeSymbolLayer};
