/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{pt2px as t}from"../../../../../../core/screenUtils.js";import{getXAnchorDirection as e,getYAnchorDirection as i}from"../../alignmentUtils.js";import{premultiplyAlphaRGBA as s}from"../../color.js";import{MIN_MAX_ZOOM_PRECISION_FACTOR as o,GLYPH_SIZE as a}from"../../definitions.js";import{i1616to32 as n}from"../../number.js";import{TextMaterialKey as r}from"../../materialKey/MaterialKey.js";import{isFunction as l,getMinMaxZoom as h}from"./util.js";import c from"./WGLBaseTextTemplate.js";import m from"./WGLDynamicMeshTemplate.js";import{codepoints as _}from"../../../../layers/features/textUtils.js";const f=5;function y(t,e,i,s){return"string"==typeof t.text?t.text:"function"==typeof t.text?t.text(e,i,s):""}class p extends(c(m)){constructor(e,i,a){super(e),this._horizontalAlignment="center",this._verticalAlignment="middle",this._textToGlyphs=new Map,this._minMaxZoom=n(Math.round(i*o),Math.round(a*o));const h=e.scaleFactor||1;if(this._cimTextLayer=e,l(e.color)){const t=(t,i,o)=>s(e.color(t,i,o));this._dynamicPropertyMap.set("_color",t)}else this._color=s(e.color);if(l(e.color)){const t=(t,i,o)=>s(e.outlineColor(t,i,o));this._dynamicPropertyMap.set("_haloColor",t)}else this._haloColor=s(e.outlineColor);let c;l(e.size)||(c=Math.min(Math.round(t(e.size*e.sizeRatio)),127));const m=(i,s,o)=>l(e.size)?Math.min(Math.round(t(e.size(i,s,o)*e.sizeRatio)),127):c;if(this._dynamicPropertyMap.set("_size",m),l(e.outlineSize)){const i=(i,s,o)=>Math.min(Math.floor(f*t(e.outlineSize(i,s,o)*e.sizeRatio)),127);this._dynamicPropertyMap.set("_haloSize",i)}else this._haloSize=Math.min(Math.floor(f*t(e.outlineSize*e.sizeRatio)),127);let _;l(e.offsetX)||(_=Math.round(t(e.offsetX*e.sizeRatio)));const y=(i,s,o)=>l(e.offsetX)?Math.round(t(e.offsetX(i,s,o)*e.sizeRatio)):_;let p;this._dynamicPropertyMap.set("_xOffset",y),l(e.offsetY)||(p=Math.round(t(e.offsetY*e.sizeRatio)));const d=(i,s,o)=>l(e.offsetY)?Math.round(t(e.offsetY(i,s,o)*e.sizeRatio)):p;this._dynamicPropertyMap.set("_yOffset",d),l(e.angle)?this._dynamicPropertyMap.set("_angle",e.angle):this._angle=e.angle,l(e.horizontalAlignment)?this._dynamicPropertyMap.set("_horizontalAlignment",e.horizontalAlignment):this._horizontalAlignment=e.horizontalAlignment,l(e.verticalAlignment)?this._dynamicPropertyMap.set("_verticalAlignment",e.verticalAlignment):this._verticalAlignment=e.verticalAlignment,this._scaleFactor=h,l(e.text)?this._dynamicPropertyMap.set("_text",e.text):this._text=e.text;const M=Math.min(Math.round(t(e.referenceSize*e.sizeRatio)),127);this._referenceSize=Math.round(Math.sqrt(256*M)),this._materialKey=e.materialKey;const g=r.load(this._materialKey);g.sdf=!0,this._bitset=(1===e.alignment?1:0)|(e.colorLocked?1:0)<<1,this._materialKey=g.data,this._decoration="none",this._lineHeight=1,this._lineWidth=512,this._textPlacement=e.markerPlacement,this._effects=e.effects,this._isCIM=!0}static fromCIMText(t,e){const[i,s]=h(t.scaleInfo,e);return new p(t,i,s)}async analyze(t,e,i,s){const o=e.readLegacyFeature(),a=y(this._cimTextLayer,o,i,s),n=await super.analyze(t,e,i,s,_(a));return n&&n.glyphMosaicItems&&this._textToGlyphs.set(a,n.glyphMosaicItems),n}bindFeature(t,s,o){const n=t.readLegacyFeature();if(this._dynamicPropertyMap.forEach(((t,e)=>{this[e]=t(n,s,o)})),!this._text||0===this._text.length)return void(this._shapingInfo=null);this._size*=this._scaleFactor,this._scale=this._size/a,this._xOffset*=this._scaleFactor,this._yOffset*=this._scaleFactor,this._xAlignD=e(this._horizontalAlignment||"center"),this._yAlignD=i(this._verticalAlignment||"baseline");const r=this._textToGlyphs.get(this._text);this.bindTextInfo(r,!1)}}export{p as default};
