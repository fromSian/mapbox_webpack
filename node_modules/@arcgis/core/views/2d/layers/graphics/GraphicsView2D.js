/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.22/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../chunks/tslib.es6.js";import e from"../../../../core/Accessor.js";import{bidiText as s}from"../../../../core/BidiText.js";import{HandleOwnerMixin as i}from"../../../../core/HandleOwner.js";import r from"../../../../core/has.js";import{isSome as o,isNone as a}from"../../../../core/maybe.js";import{throwIfAborted as h,isAbortError as n,throwIfAbortError as l}from"../../../../core/promiseUtils.js";import{property as d}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/arrayUtils.js";import"../../../../core/accessorSupport/ensureType.js";import{subclass as p}from"../../../../core/accessorSupport/decorators/subclass.js";import c from"../../../../geometry/SpatialReference.js";import{width as g,height as u,create as m}from"../../../../geometry/support/aaBoundingRect.js";import{closeRingsAndFixWinding as _}from"../../../../geometry/support/coordsUtils.js";import{getJsonType as f,isPolygon as y,isPolyline as b,isExtent as S,isPoint as w,isMultipoint as T}from"../../../../geometry/support/jsonUtils.js";import{normalizeCentralMeridianSync as I}from"../../../../geometry/support/normalizeUtilsSync.js";import{getInfo as v}from"../../../../geometry/support/spatialReferenceUtils.js";import{checkProjectionSupport as G,project as U}from"../../../../layers/graphics/data/projectionSupport.js";import{symbolToCIM as M}from"../../../../symbols/cim/CIMSymbolHelper.js";import{errorPolylineSymbol2D as C,errorPolygonSymbol2D as j,errorPointSymbol2D as P}from"../../../../symbols/support/defaults.js";import{FILTER_FLAG_0 as x}from"../../engine/webgl/definitions.js";import{GraphicTile as A}from"../../engine/webgl/GraphicTile.js";import{TileData as R}from"../../engine/webgl/TileData.js";import q from"../../engine/webgl/WGLDisplayObject.js";import{MeshData as z}from"../../engine/webgl/mesh/MeshData.js";import{WGLMeshFactory as D}from"../../engine/webgl/mesh/factories/WGLMeshFactory.js";import{WGLTemplateStore as H}from"../../engine/webgl/mesh/templates/WGLTemplateStore.js";import{createMatcher as O}from"../../engine/webgl/util/Matcher.js";import{createMatcherSchema as F,createSymbolSchema as k}from"../features/schemaUtils.js";import E from"../features/support/AttributeStore.js";import{ComputedAttributeStorage as N}from"../features/support/ComputedAttributeStorage.js";import{GraphicsReader as V}from"../features/support/GraphicsReader.js";import B from"./GraphicStore.js";import{intersectingInternationalDateline as L,isMarkerSymbol as W,isTextSymbol as J,polygonFromExtent as Z,TILE_SIZE as K,PIXEL_BUFFER as Q}from"./graphicsUtils.js";import{expandSymbol as X}from"../support/cimSymbolUtils.js";import{GraphicsView as Y}from"../../../layers/GraphicsView.js";import $ from"../../../webgl/capabilities.js";const tt=r("esri-2d-graphic-debug");function et(t,e,s){if(s.has(t))return s.get(t);const i={tile:e,addedOrModified:[],removed:[]};return s.set(t,i),i}let st=class extends(Y(i(e))){constructor(t){super(t),this._storage=new N,this._displayIds=new Map,this._controller=new AbortController,this._tiles=new Map,this._graphicStoreUpdate=!1,this._graphicsSet=new Set,this._matcher=Promise.resolve(null),this._tileUpdateSet=new Set,this._tilesToUpdate=new Map,this._graphicIdToAbortController=new Map,this._attached=!1,this._highlightIds=new Map,this._updatingGraphicsTimer=null,this._hashToExpandedSymbol=new Map,this._hashToExpandedSymbolPromise=new Map,this._hashToCIMSymbolPromise=new Map,this._hashToCIM=new Map,this._processing=!1,this._needsProcessing=!1,this._pendingUpdate={added:new Set,updated:new Set,removed:new Set},this.lastUpdateId=-1,this.updateRequested=!1,this.graphicUpdateHandler=this.graphicUpdateHandler.bind(this)}_createMatcher(t,e,s){if(t){const i=F({indexCount:0,fields:{}},"feature",t);this._matcher=O(i,e,null,s)}}_createDisplayId(t){return this._displayIds.has(t)||this._displayIds.set(t,this._storage.createDisplayId()),this._displayIds.get(t)}initialize(){this._attributeStore=new E({type:"local",initialize:t=>Promise.resolve(this.container.attributeView.initialize(t)),update:t=>this.container.attributeView.requestUpdate(t),render:()=>this.container.requestRender()},$()),this.container.hasHighlight=()=>!!this._highlightIds.size;const t=t=>{this._createDisplayId(t.uid),this._setFilterState(t.uid,t.visible)},e=t=>{const e=this._displayIds.get(t.uid);this._displayIds.delete(t.uid),this._storage.releaseDisplayId(e)},s=new H(this.container.getMaterialItems.bind(this.container),this.view.featuresTilingScheme.tileInfo);this._graphicStore=new B(this.view.featuresTilingScheme,this.view.state.scale,this.uid,this.graphics,t,e,this._hashToCIM),this._meshFactory=new D(null,this.uid,s),this._templateStore=s,this.handles.add([this.watch("renderer",(t=>{this._createMatcher(t,s,this.container.stage.resourceManager);for(const e of this.graphics)this._pendingUpdate.updated.add(e);this.requestUpdate()})),this.view.graphicsTileStore.on("update",(t=>this._onTileUpdate(t))),this.container.on("attach",(()=>{tt&&this.container.enableRenderingBounds((()=>this._graphicStore.getAllBounds())),this.graphics.items.length>0&&this._graphicsChangeHandler({target:this.graphics,added:this.graphics.items,removed:[],moved:[]}),this.handles.add(this.graphics.on("change",(t=>this._graphicsChangeHandler(t))),"graphics");const t=this.container.stage.resourceManager;this._createMatcher(this.renderer,s,t),this._graphicStore.setResourceManager(t),this._attached=!0,this.notifyChange("updating")}))]);const i=this.view.graphicsTileStore.tiles;this._onTileUpdate({added:i,removed:[]})}destroy(){this._updatingGraphicsTimer&&(clearTimeout(this._updatingGraphicsTimer),this._updatingGraphicsTimer=null,this.notifyChange("updating")),this._controller.abort(),this.container.destroy(),this._set("graphics",null),this._graphicStore.clear(),this._attributeStore=null,this._hashToExpandedSymbol.clear(),this.view=null,this.renderer=null,this._hashToCIM.clear(),this._hashToCIMSymbolPromise.clear(),this._hashToExpandedSymbolPromise.clear()}get updating(){return!this._attached||null!==this._updatingGraphicsTimer||this._tileUpdateSet.size>0||this._tilesToUpdate.size>0}hitTest(t){if(!this.view||!this.view.position)return null;const{resolution:e,rotation:s}=this.view.state;return this._graphicStore.hitTest(t.x,t.y,2,e,s)}update(t){h(this._controller.signal);const e=t.state,{resolution:s}=e;if(this._graphicStore.updateLevel(s),this._graphicStoreUpdate=!0,this.updateRequested=!1,this._pendingUpdate.updated.size>0){if(!this._processing)return void this._updateGraphics();this._needsProcessing=!0}}viewChange(){this.requestUpdate()}requestUpdate(){this.updateRequested||(this.updateRequested=!0,this.requestUpdateCallback())}processUpdate(t){this.updateRequested&&(this.updateRequested=!1,this.update(t))}graphicUpdateHandler(t){const{graphic:e,property:s,newValue:i}=t;switch(s){case"attributes":break;case"geometry":case"symbol":this._pendingUpdate.updated.add(e),this.requestUpdate();break;case"visible":this._setFilterState(e.uid,i),this._attributeStore.sendUpdates()}}addHighlight(t){for(const e of t)if(this._highlightIds.has(e)){const t=this._highlightIds.get(e);this._highlightIds.set(e,t+1)}else this._highlightIds.set(e,1);this._updateHighlight()}removeHighlight(t){for(const e of t)if(this._highlightIds.has(e)){const t=this._highlightIds.get(e)-1;0===t?this._highlightIds.delete(e):this._highlightIds.set(e,t)}this._updateHighlight()}_updateHighlight(){const t=Array.from(this._highlightIds.keys()),e=t.map((t=>this._displayIds.get(t)));this._attributeStore.setHighlight(t,e)}_getIntersectingTiles(t){const e=this._graphicStore.getBounds(t);if(!e||0===g(e)||0===u(e))return[];const s=L(e,this.view.spatialReference);return o(s)?[...new Set([...this.view.graphicsTileStore.boundsIntersections(s[0]),...this.view.graphicsTileStore.boundsIntersections(s[1])])]:this.view.graphicsTileStore.boundsIntersections(e)}async _updateTile(t){h(this._controller.signal);const e=t.tile,s=this._getGraphicsData(this._templateStore,e,t.addedOrModified),i=await this._processGraphics(e,s);return h(this._controller.signal),this._patchTile(e.key,{type:"update",addOrUpdate:i,remove:t.removed,end:!0,clear:!1,sort:!1}),i}_patchTile(t,e){if(!this._tiles.has(t))return;const s=this._tiles.get(t);this.container.onTileData(s,e),this.container.requestRender()}_graphicsChangeHandler(t){const e=this._pendingUpdate;for(const s of t.added)e.added.add(s);for(const s of t.moved)e.updated.add(s);for(const s of t.removed)this._pendingUpdate.added.has(s)?e.added.delete(s):e.removed.add(s);this._processing?this._needsProcessing=!0:this._updateGraphics()}_getGraphicsToUpdate(){const t={added:[],removed:[],updated:[]};if(!this.graphics)return t;const e=this._pendingUpdate;for(const s of this.graphics.items)e.added.has(s)?t.added.push(s):e.updated.has(s)&&t.updated.push(s);for(const s of e.removed)this._graphicStore.has(s)&&t.removed.push(s);return e.added.clear(),e.removed.clear(),e.updated.clear(),t}async _updateGraphics(){this._processing=!0;const{added:t,removed:e,updated:s}=this._getGraphicsToUpdate(),i=this._tilesToUpdate;let r;try{if(!this._graphicStoreUpdate){const t=this.view.state,{resolution:e}=t;this._graphicStore.updateLevel(e)}const o=[],a=new Array(t.length+e.length);for(let t=0;t<s.length;t++){const e=s[t],h=this._getIntersectingTiles(e);for(const t of h){r=t.id;et(r,t,i).removed.push(this._displayIds.get(e.uid))}o.push(this._updateGraphic(e,null)),a[t]=e}const h=s.length;for(let e=0;e<t.length;e++){const s=t[e];a[h+e]=s,this._graphicsSet.add(s),o.push(this._addGraphic(s))}for(const t of e){this._abortProcessingGraphic(t.uid);const e=this._getIntersectingTiles(t);for(const s of e){r=s.id;et(r,s,i).removed.push(this._displayIds.get(t.uid))}this._graphicsSet.delete(t),this._graphicStore.remove(t)}let n;this._flipUpdatingGraphics(),await Promise.all(o);for(let t=0;t<a.length;t++){n=a[t];const e=this._getIntersectingTiles(n);for(const t of e){r=t.id;et(r,t,i).addedOrModified.push(n)}}this._graphicStore.updateZ();const l=[];for(const[t,e]of i)l.push(this._updateTile(e));await Promise.all(l)}catch(o){n(o),0}for(const a of e)try{const t=await this._getSymbolForGraphic(a,{});if(t){const e=t.hash();this._hashToExpandedSymbol.delete(e)}}catch(o){n(o),0}i.clear(),this.notifyChange("updating"),this._processing=!1,this._needsProcessing&&(this._needsProcessing=!1,this._updateGraphics())}_getArcadeInfo(t){const e=(t.attributes?Object.keys(t.attributes):[]).map((e=>({name:e,alias:e,type:"string"==typeof t.attributes[e]?"esriFieldTypeString":"esriFieldTypeDouble"})));return a(t.geometry)?null:{geometryType:f(t.geometry),spatialReference:c.fromJSON(t.geometry.spatialReference),fields:e}}_getSymbolForGraphic(t,e){return h(this._controller.signal),o(t.symbol)?Promise.resolve(t.symbol):o(this.renderer)?this.renderer.getSymbolAsync(t,{scale:this.view.scale,abortOptions:e}):Promise.resolve(this._getNullSymbol(t))}_getCIMSymbol(t,e,s){let i=this._hashToCIM.get(e);if(i)return Promise.resolve(i);const r=M(t);if(o(r)){if("CIMSymbolReference"===r.type)return i=r,this._hashToCIM.set(e,i),Promise.resolve(i);let t=this._hashToCIMSymbolPromise.get(e);return t||(t=r.fetchCIMSymbol(s).then((t=>(this._hashToCIM.set(e,t.data),this._hashToCIMSymbolPromise.delete(e),t))).catch((t=>(this._hashToCIMSymbolPromise.delete(e),l(t),null))),this._hashToCIMSymbolPromise.set(e,t),t)}return Promise.resolve(null)}_expandCIMSymbol(t,e,s,i){const r=this._hashToExpandedSymbol.get(s);if(r)return Promise.resolve(r);let o=this._hashToExpandedSymbolPromise.get(s);if(o)return o;const a=this.container.stage,h=this._getArcadeInfo(e),n=k(t);return o=X(n,h,a.resourceManager,i),this._hashToExpandedSymbolPromise.set(s,o),o.then((t=>(this._hashToExpandedSymbol.set(s,t),this._hashToExpandedSymbolPromise.delete(s),t))),o}async _getSymbolResources(t,e){h(this._controller.signal);return this.container.stage?this._getSymbolForGraphic(t,e).then((i=>{const r=i.hash();return this._getCIMSymbol(i,r,e).then((i=>a(i)?null:this._expandCIMSymbol(i,t,r,e).then((t=>{const e=t.layers.filter((t=>"text"===t.type&&"string"==typeof t.text));if(e&&e.length>0){const i=new Array(e.length);for(let t=0;t<e.length;t++){const r=e[t],o=[],[a]=s(r.text);for(let t=0;t<a.length;t++)o.push(a.charCodeAt(t));i[t]={symbol:r,id:t,glyphIds:o}}const o=new Map;return this.container.getMaterialItems(i).then((s=>{for(let t=0;t<e.length;t++){const i=e[t];o.set(i.cim,{text:i.text,mosaicItem:s[t].mosaicItem})}return{symbol:t,textInfo:o,hash:r}}))}return{symbol:t,hash:r}}))))})).catch((t=>(l(t),null))):null}async _projectAndNormalizeGeometry(t,e){if(h(this._controller.signal),a(t.geometry)||"mesh"===t.geometry.type)return null;let s=t.geometry;if(y(s)){const t=s.rings;s.rings=t}else if(b(s)){const t=s.paths;s.paths=t}else if(S(s)){const i=await this._getSymbolForGraphic(t,e);if(h(this._controller.signal),W(i.type)||J(i.type)){s=s.center}else s=Z(s)}await G(s.spatialReference,this.view.spatialReference);const i=I(s),r=U(i,s.spatialReference,this.view.spatialReference);return _(r),r}_onTileUpdate(t){const e=v(this.view.spatialReference);if(t.added&&t.added.length>0)for(const s of t.added)this._addNewTile(s,e);if(t.removed&&t.removed.length>0)for(const s of t.removed)this._removeTile(s.key)}async _addGraphic(t){this._abortProcessingGraphic(t.uid),h(this._controller.signal);const e=new AbortController;this._graphicIdToAbortController.set(t.uid,e);const s={signal:e.signal};try{await this._addOrUpdateGraphic(t,s),h(this._controller.signal),this._graphicIdToAbortController.delete(t.uid)}catch(i){if(this._graphicIdToAbortController.delete(t.uid),!n(i))throw i}}_updateGraphic(t,e){h(this._controller.signal);const s=this._projectAndNormalizeGeometry(t,e),i=this._getSymbolResources(t,e);return Promise.all([s,i]).then((([e,s])=>{h(this._controller.signal),this._graphicStore.addOrModify(t,s,e)}))}_addOrUpdateGraphic(t,e){h(this._controller.signal);const s=this._projectAndNormalizeGeometry(t,e),i=this._getSymbolResources(t,e);return Promise.all([s,i]).then((([e,s])=>{h(this._controller.signal),this._graphicsSet.has(t)&&this._graphicStore.addOrModify(t,s,e)}))}_addTile(t){const e=this.view.featuresTilingScheme.getTileBounds(m(),t),s=new A(t,e[0],e[3]);return this._tiles.set(t,s),this.container.addChild(s),s}async _addNewTile(t,e){const s=this._addTile(t.key),i=this._graphicStore.queryTileData(this._templateStore,t);if(0===i.length)return;if(e){const s=Math.round((e.valid[1]-e.valid[0])/t.resolution);for(const t of i)t.geometry&&(w(t.geometry)||T(t.geometry))&&this._wrapPoints(t,s)}const r=t.key;this._tileUpdateSet.add(t.key),this.notifyChange("updating");try{const e={type:"update",clear:!1,addOrUpdate:await this._processGraphics(t,i),remove:[],end:!0,sort:!1};s.patch(e),this._tileUpdateSet.delete(r),this.notifyChange("updating")}catch(o){if(this._tileUpdateSet.delete(r),this.notifyChange("updating"),!n(o))throw o}}_removeTile(t){if(!this._tiles.has(t))return;const e=this._tiles.get(t);this.container.removeChild(e),e.destroy(),this._tiles.delete(t)}_setFilterState(t,e){const s=this._displayIds.get(t),i=this._attributeStore.getHighlightFlag(t);this._attributeStore.setData(s,0,0,i|(e?x:0))}_getGraphicsData(t,e,s){const i=this.view,r=v(i.spatialReference),o=this._graphicStore.getGraphicsData(t,e,s);if(r){const t=Math.round((r.valid[1]-r.valid[0])/e.resolution);for(const e of o)e.geometry&&(w(e.geometry)||T(e.geometry))&&this._wrapPoints(e,t)}return o}_wrapPoints(t,e){const s=t.geometry;T(s)?this._wrapMultipoint(s,e):this._wrapPoint(t,e)}_wrapMultipoint(t,e){const s=t.points,i=[];let r=0,o=0;for(const[a,h]of s){if(i.push([a+r,h]),r=0,e===K){const t=5*Q;a+o<t?(i.push([e,0]),r=-e):a+o>K-t&&(i.push([-e,0]),r=e)}else a+o<-Q?(i.push([e,0]),r=-e):a+o>K+Q&&(i.push([-e,0]),r=e);o+=a}t.points=i}_wrapPoint(t,e){const s=t.geometry;if(e===K){const i=5*Q;s.x<i?t.geometry={points:[[s.x,s.y],[e,0]]}:s.x>K-i&&(t.geometry={points:[[s.x,s.y],[-e,0]]})}else s.x<-Q?t.geometry={points:[[s.x,s.y],[e,0]]}:s.x>K+Q&&(t.geometry={points:[[s.x,s.y],[-e,0]]})}_processGraphics(t,e,s){if(!(e&&e.length)||!this._meshFactory)return null;const i=V.from(e),r=this._meshFactory;return this._matcher.then((e=>r.analyzeGraphics(i,this.container.stage.resourceManager,e,null,null,s).then((()=>(this._attributeStore.sendUpdates(),this._processAnalyzedGraphics(t,i))))))}_processAnalyzedGraphics(t,e){const s=this._meshFactory,i=e.getSize(),r=e.getCursor(),o={features:i,records:i,metrics:0},a=new z(t.key.id,o,{fill:"default"},!1,!1),h=[];for(;r.next();){const e=r.readGraphic();e.insertAfter=-1===e.insertAfter?-1:this._displayIds.get(e.insertAfter),e.displayId=this._displayIds.get(e.attributes[this.uid]);const i=new q(e.displayId);i.insertAfter=e.insertAfter,h.push(i),s.writeGraphic(a,r,t.level)}const n=t.tileInfoView.tileInfo.isWrappable,l=a.serialize(n);if(1!==l.length)return new R;const d=l[0].message;return R.fromVertexData(d,h)}_abortProcessingGraphic(t){if(this._graphicIdToAbortController.has(t)){this._graphicIdToAbortController.get(t).abort()}}_getNullSymbol(t){const e=t.geometry;return b(e)?C:y(e)||S(e)?j:P}_flipUpdatingGraphics(){this._updatingGraphicsTimer&&clearTimeout(this._updatingGraphicsTimer),this._updatingGraphicsTimer=setTimeout((()=>{this._updatingGraphicsTimer=null,this.notifyChange("updating")}),160),this.notifyChange("updating")}};t([d({constructOnly:!0})],st.prototype,"requestUpdateCallback",void 0),t([d()],st.prototype,"container",void 0),t([d({constructOnly:!0})],st.prototype,"graphics",void 0),t([d()],st.prototype,"updating",null),t([d()],st.prototype,"view",void 0),t([d()],st.prototype,"updateRequested",void 0),st=t([p("esri.views.2d.layers.support.GraphicsView2D")],st);const it=st;export{it as default};
